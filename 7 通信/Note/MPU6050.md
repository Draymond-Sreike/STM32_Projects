# MPU6050

> ![image-20230209142544954](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209142544954.png)

- 6轴：现实空间中本来只有xyz三轴，但是由于该芯片有加速度计和陀螺仪传感器，每根轴可以测量加速度和角速度，这样加起来总共就是6轴了；

    如果再加一个磁场传感器测量每根轴的磁场强度，那就是9轴姿态传感器了；

    如果再测量一下空间中的气压大小，就是10轴姿态传感器（一般气压值反映的是高度信息，海拔越高气压越低，所以气压计是单独测量垂直地面的高度信息的）

- 这么多轴的存在是为了采集这些信息，用于“数据融合，进一步得到姿态角”（姿态角也可以叫欧拉角）

    有关欧拉角的解释见视频 [04:00~05:00](https://www.bilibili.com/video/BV1th411z7sn?p=32&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

    加速度计、陀螺仪、磁力计任何一种传感器都无法获得精确且稳定的欧拉角，要想获得精确且稳定的欧拉角，就必须进行数据融合，把这集中传感器的数据融合起来，综合多种传感器的数据，取长补短，这样才能获得精确且稳定的欧拉角。

    常见的数据融合算法有：互补滤波、卡尔曼滤波等，这属于惯性导航领域里姿态解算的知识点了。

    对于平衡车，如果传感器检测到车身向前或向后倾斜了，程序就可以控制轮子进行调整，以保持平衡车的平衡

- 有关加速度计的物理原理讲解见视频 [06:50~10:20](https://www.bilibili.com/video/BV1th411z7sn?p=32&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)
    - 加速度计由于只能在静态下测量角度，运动状态下无法测量角度（具体解释同样见视频）因而**具有静态稳定性而不具有动态稳定性**

- 有关陀螺仪传感器的物理原理讲解见视频 [10:20~13:20](https://www.bilibili.com/video/BV1th411z7sn?p=32&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

    - 陀螺仪传感器由于只能获得角速度值，如果要获得角度则需要对角速度进行积分，但是这种方式对于传感器来说有局限：角速度值在物体静止时，会由于噪声而无法完全归零，因此经过积分的不断累积，这就会导致计算出来的角度产生缓慢的偏移，也就是角速度积分得到的角度经不起时间的考验，不过这个角度计算原理对于静止或运动都是没有问题的，所以**陀螺仪传感器具有动态稳定性，而不具备静态稳定性**

    因此加速度计和陀螺仪传感器的特性正好互补，因此我们就可以进行互补滤波，从而就能得到静态和动态都稳定的姿态角/欧拉角了，这是姿态结解算的大体思路。

## MPU6050重要参数

> ![image-20230209181436630](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209181436630.png)

- 量程选择：如果我们所测量的物体运动非常剧烈，就可以把满量程选择大一些，防止加速度或角速度超出了量程；如果物体运动比较平缓，就可以选择较小的量程，这样测量的分辨率就会更大（例如选加速度计选±16g的量程，那么每个单位就是16/32767≈0.0005，如果选±2g，每个单位就是2/23767≈0.00006），因为AD值的范围是固定的-32768~32767，所以如果我们满量程选得越小，测量一个AD单位值对应的实际值量化就会越细腻

- 数字低通滤波器：在该芯片里可以配置寄存器来选择对输出数据进行低通滤波，如果输出数据抖动太厉害就可以加一些低通滤波，这样输出数据就会平缓一些

- 时钟源&采样分频：时钟源经过分频器的分频可以为AD转换和内部其他电路提供时钟，控制分配系数就可以控制AD转换的快慢了

- I2C从机地址：地址是7位的，如果我们要对这7位用16进制来表示的话，一般会有两种表示方式，我们一1101000为例：

    1. 认为0x68是MPU6050的地址。这种理解方式是单纯地将从机地址的7位二进制数转化为16进制，低4位和高3位切开：110 1000，高三位最左边一位补0，此时转化成16进制就是0x68，这是MPU6050的真实地址

    但是由于我们在进行从机寻址时还要在从机地址的后一位发送读写标志位：

    > ![image-20230209183305310](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209183305310.png)

    所以在发送从机地址+读写标志位组合成的这个字节时，需要先对0x68左移一位，再**或**上读写标志位（读1[0x01]、写0[0x00]），这样才能如上图所示这样得到一个正确的由从机地址和读写标志位组合成的字节

    2. 认为0x68左移一位后得到的0xD0是MPU6050的地址。这时如果我们要执行写操作，就直接把0xD0当中第一个字节发送，而如果要执行读操作就把0xD0或上1[0x01]，即0xD1当作第一个字节，这种操作方式相当于已经提前进行了左移操作，或者说这种表示方式是把读写位融入到了从机地址里：0xD0是写地址，0xD1是读地址

## 硬件电路

> ![image-20230209184016680](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209184016680.png)

- INT引脚是中断输出引脚，可以配置芯片内部的一些事件来触发中断引脚的输出，例如数据装备完毕、I2C主机错误等，另外芯片内部还内置了一些实用小功能：自由落体检测、运动检测、零运动检测等，这些都可以触发INT引脚产生电平跳变，需要的话可以进行中断配置

## MPU6050框图

> ![image-20230209194540510](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209194540510.png)

- 框图中灰色框部分就是传感器，本质上也相当于可变电阻，通过分压后输出模拟电压，然后通过ADC进行模数转换，转换完成后这些传感器的数据统一放到数据寄存器中（SenSor Registors），我们读取数据寄存器就能得到传感器测量的值了。

    - 在此过程中芯片内部的转化都是全自动进行的，类似前面所学的AD连续转换+DMA转运（目前还没学。。。）

    - 每个ADC输出（各自）对应16位的数据寄存器，不存在数据覆盖的问题
    - 我们配置好转换频率后，每个数据就自动以我们设置的频率刷新到数据寄存器，我们需要数据的时候直接来读就行

- 另外这个芯片的每个测量对象还都有一个自测单元（Self tesst），用来验证芯片损坏与否，其使用原理见视频 [27:40~28:25](https://www.bilibili.com/video/BV1th411z7sn?p=32&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

- 另外芯片内还有一个电荷泵（Charge Pump，也叫充电泵），是一种升压电路，电荷泵的升压原理见视频 [28:25~30:00](https://www.bilibili.com/video/BV1th411z7sn?p=32&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

框图中右半部分就是寄存器和通信接口部分了：

> ![image-20230209195812705](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209195812705.png)

- 中断状态寄存器（Interrupt Status Register）可以控制内部哪些事件到中断引脚输出
- 先入先出寄存器（FIFO），可以对数据流进行缓存
- 配置寄存器（Config Register），可以对内部的各个电路进行配置
- 传感器寄存器（Sensor Registor）也即数据寄存器，存储了各个传感器的数据
- 数字运动处理器（简称DMP），是芯片内部自带的一个姿态解算的硬件算法，配合官方的DMP库可以进行姿态结算（因为姿态结算还是比较难的，且算法较复杂，如果使用内部的这个DMP，姿态解算就会方便一些）

# 产品说明书使用

该部分见视频[32:20~41:30](https://www.bilibili.com/video/BV1th411z7sn?p=32&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

> 指定地址写一个字节、指定地址写多个字节：
>
> ![image-20230209203605358](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209203605358.png)

> 指定地址读一个字节、多个字节
>
> ![image-20230209203718012](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209203718012.png)

# 寄存器映像手册使用

此部分内容见视频 [41:30~](https://www.bilibili.com/video/BV1th411z7sn?p=32&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

MPU6050的寄存器是8位的：

> ![image-20230209204806035](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209204806035.png)
>
> SMPLRT_DIV：采样频率分频器
>
> CONFIG：配置寄存器
>
> GYRO_CONFIG：陀螺仪配置寄存器
>
> ACCEL_CONFIG：加速度配置寄存器

> 数据寄存器：
>
> 包括加速度计和陀螺仪XYZ、温度传感器的数据：
>
> ![image-20230209204921340](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209204921340.png)
>
> _L表示低8位，\_H表示高8位

> ![image-20230209205050125](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209205050125.png)
>
> PWR_MGMT：电源管理寄存器
>
> WHO_AMI：器件ID

## SMPLRT_DIV：采样频率分频器

> ![image-20230209205237042](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209205237042.png)

- 该寄存器的8位作为一个整体，配置分频值，决定采用频率的分配系数
- 简单来说就是分频越小，内部的AD转换就越快，数据寄存器的刷新就越快；反之就越慢
- 采样频率（可以理解为数据刷新率）等于陀螺仪时钟频率/(1+分频值)，这里的陀螺仪时钟是作为一个例子举出，也可以是芯片内部晶振、陀螺仪晶振和外部时钟引脚的方波
- 注意事项：不使用低通滤波器时，陀螺仪时钟为8KHz；使用了滤波器，时钟就是1KHz

## CONFIG：配置寄存器

> ![image-20230209205748713](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209205748713.png)

- 该8位寄存器单元内部分成两部分：EXT_SYNC_SET：外部同步设置、DLPF_CFG：低通滤波器设置

- 外部同步暂时不用可以不看，数字低通滤波器：

    > ![image-20230209210103888](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209210103888.png)
    >
    > 低通滤波器可以让输出数据更平滑，配置滤波参数越大，输出数据抖动就越小，数据越平滑

    - 配置DLPF_CFG位可以选择上图所示的各种滤波参数
    - 0是不使用滤波器，陀螺仪时钟为0
    - 之后1~6使用了低通滤波器，陀螺仪时钟就是1KHz
    - 7是保留值没有用到

## GYRO_CONFIG：陀螺仪配置寄存器

> ![image-20230209210407576](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209210407576.png)
>
> ST：自测使能位
>
> FS_SEL：满量程选择位

- 自测：确定**自测响应**在正常范围，如果在范围内则可以正常使用芯片

    - 自测响应=自测使能时的数据-自测失能时的数据

    - 上电后先使能自测，读取数据，再使能自测，读取数据，两者相减便能得到自测响应

    - 自测响应正常范围（在产品说明书中）：

        > ![image-20230209211007532](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209211007532.png)

- 满量程选择：

    > ![image-20230209211036177](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209211036177.png)

## ACCEL_CONFIG：加速度配置寄存器

> ![image-20230209211119706](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209211119706.png)
>
> ST：自测使能位
>
> AFS_SEL：满量程选择
>
> ACCEL_HPF：配置高通滤波器（内置小功能运动检测时用到的，对数据输出没有影响，暂时用不到）

- 满量程选择：

    > ![image-20230209214221948](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209214221948.png)

## 加速度计数据寄存器

我们想读取数据的话直接读取数据寄存器即可：

> ![image-20230209214250460](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209214250460.png)

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209214357493.png" alt="image-20230209214357493" style="zoom: 67%;" />
>
> 这是一个16位的有符号数，以二进制补码的形式存储，我们可以读出高8位和低8位，再将高位左移8位后，**或**上低8位，最后存在一个int16_t的变量里，这样就能得到数据了

## 温度传感器数据寄存器

> ![image-20230209214631611](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209214631611.png)

操作方法与加速度计数据寄存器相同

## 陀螺仪数据寄存器

> ![image-20230209214657796](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209214657796.png)
>
> ![image-20230209214705246](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209214705246.png)

操作方法与加速度计数据寄存器相同

## 电源管理寄存器

### 1

> ![image-20230209214744122](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209214744122.png)
>
> DEVICE_RESET：设备复位。这一位写1，所有寄存器都恢复默认值
>
> SLEEP：睡眠模式。写1芯片睡眠，芯片不工作进入低功耗状态
>
> CYCLE：循环模式。写1设备进入低功耗，过一段时间启动一次，唤醒的频率由下一个寄存器中的LP_WAKE_CTRL确定：
>
> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209215047873.png" alt="image-20230209215047873" style="zoom:33%;" />
>
> 这个模式比较省电
>
> TEMP_DIS：温度传感器失能。写1禁用内部的温度传感器
>
> CLKSEL：选择系统时钟来源。配置参考下表：
>
> ![image-20230209215240371](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209215240371.png)
>
> - 0：内部晶振
> - 1~3：XYZ轴陀螺仪晶振
> - 4~5：外部引脚的两个方波
>
> 一般我们选择内部晶振或陀螺仪晶振。不过如上图蓝色高亮所描述的：非常建议选择陀螺仪晶振（因为陀螺仪晶振更加精确）

### 2

> ![image-20230209215549103](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209215549103.png)
>
> LP_WAKE_CTRL：循环模式下芯片的唤醒频率
>
> STBY：控制各个轴进入待机模式。

## WHO_AM_I：设备ID

> ![image-20230209215727138](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209215727138.png)

- 该寄存器只读，ID号不可修改
- 中间的WHO_AM_I位固定为110100，而最高和最低两位：Bit7和Bit0实际上都是0，所以整个WHO_AM_I寄存器就是0110 1000读出来就是0x68，即该芯片的ID就是0x68
- ID号其实就是这个芯片的地址：0x68
- AD0引脚的值并不反映在这个寄存器上：我们之前说过这个芯片的I2C地址可以通过AD0引脚进行配置，但是这里WHO_AM_I这个8位寄存器单元的最低位Bit0是不随AD0引脚的变化而变化的，始终都固定是0，所以读出ID号始终都是0x68（这个**ID号不一定非要和I2地址一致**）
- 但是这个ID地址作为I2C通信中发送的第一个字节的时序单元（从机地址+读/写标志位）中时，从机地址的值是1101 000，跟上读写标志位1/0就是1101 0000（0xD0写）或1101 0001（0xD1读），再配合如果将AD0引脚接到高电平就是1101 0010（0xD2写）或1101 0011（0xD3读）

# 所以寄存器上电默认值都是0x00；操作芯片要先解除睡眠模式

> ![image-20230209220537029](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209220537029.png)

- 107：电源管理寄存器1默认上电为0x40。0x40(0100 0000)，对应就是SLEEP为1，所以也就是说芯片上电时默认是睡眠模式。所以我们在**操作芯片之前要先解除睡眠**，否则操作其他寄存器是无效的
- 117：对应WHO_AM_I单元，0x68毋庸置疑！