# 通信

## 通信协议比较

> ![image-20230208122242917](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208122242917.png)

- **双工**：指的是两台设备之间允许有双向的数据传输
    - 全双工：指通信双方能够**同时**进行双向通信。一般来说全双工的通信都会有两根通信线（例如：串口TX发送、RX接收；SPI的MOSI发送，MOSI接收），发送线路和接收线路互不影响，就是全双工的特点
    - 半双工：指通信双方**不能同时**进行双向通信。因为半双工的通信都只有一根数据线，其中一者在使用，另一者就无法使用了，所以无法同时进行双向通信。I2C、CAN和USB都只有一根数据线（CAN的H和L、USB的DP和DM都算是组合成一根数据线的）
    - 单工：指的是数据只能从一个设备到另一个设备，而不能反着来，即两台设备之间的数据只能单向传输（例如把串口的RX去掉，此时串口就退化成单工了）

- **时钟特性**：

    比如我们发送一个波形：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208132122335.png" alt="image-20230208132122335" style="zoom:50%;" />
    >
    > 先高电平，然后低电平

    这时接收方要怎么知道我们发送的是1、0还是1、1、0、0呢？这就需要有一个时钟信号来告诉对方如何对我们发送的这个信号进行读取采集：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208132324868.png" alt="image-20230208132324868" style="zoom:50%;" />

    这就是通信的时钟的用处。

    同步通信要求接收端时钟频率和发送端时钟频率一致，发送端发送连续的比特流；

    - 同步通信，就是送快递的面对面给交你，交互完成即完在，但双方都需要在同一时间内反应，否则会造成另一方阻塞等待

    异步通信时不要求接收端时钟和发送端时钟同步，发送端发送完一个字节后，可经过任意长的时间间隔再发送下一个字节；

    - 异步通信，就是送快递的放在门卫或快递箱，你自己去取，中间不是同步完成的

    这里I2C和SPI都有单独的时钟线（SCL、SCLK），接收方可以在时钟信号的指引下进行采样，所以他们是同步的；

    剩下的串口、CAN和USB都没有时钟线，所以需要双方约定一个信号采样的时钟，并且还可能要加一些帧头帧尾等，进行采样位置的对齐，这就是异步通信。

- **电平特性**：

    - 串口、I2C和SPI都是单端信号，也就是它们引脚的高低电平都是对GND的电压差，所以单端信号通信的双方必须要共地，就是把GND接在一起，如果不接GND是没办法通信的。也就是说实际上这三种通信协议还应该加一个GND的通信引脚，

    - CAN和USB是差分信号，它们是靠两个引脚间的电压差来传输信号的，通信的时候可以不用GND（不过USB协议里面也有一些是需要单端信号的，所以USB还是得共地的）。使用**差分信号可以极大地提高抗干扰特性**，所以差分信号一般传输速度和距离都会比较高，性能也很不错。

- **设备特性**：

    - 串口和USB属于点对点的通信。点对点通信就相当于老师找同学去办公室单独谈话，只有两个人，直接传输数据即可
    - I2C、CAN和SPI是多设备，可以在总线上挂载多个设备。多设备就相当于老师在教室里面向全班（但是只对一名同学）讲话，需要有一个寻址的过程，以确定通信的对象

# I2C通信

> ![image-20230208133732815](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208133732815.png)

- 因为I2C是同步 时序，软件模拟协议非常方便

- 单片机外接芯片的外设也是通过读写寄存器来控制运行的，如果我们要通过**读写来控制硬件电路**，则**至少需要定义两个字节的数据**，一个字节用来指定所要读写的寄存器的地址，另一个字节就是要写入这个寄存器的内容或者是用于存放从这个寄存器读取到的内容。写入内容就是控制电路，读出内容就是获取电路状态。这种操作其他芯片寄存器的流程和我们单片机CPU操作外设的原理是一样的。

- 通信协议设计背景：

    1. 两个设备之间不需要同时进行发送或接收，所以只需要一根数据线，即半双工

    2. 设置应答机制，设备1发送给另一个设备2数据后，设备2在成功接收时需要给设备1一个接收成功的应答回复

    3. 总线上允许搭载多个模块。单片机可以指定与这些模块中的其中一个进行通信，同时在与某个模块通信时，其他的模块不能对该通信产生干扰

    4.  同步。如果采用串口通信，那是异步时序的，这时发送方和接收方约定的传输速率是非常严格的，时钟不能有过大的偏差，也不能是这样的情况：在通信的过程中，单片机有点事进了一个中断，此时通信的时序被迫暂停，对于异步通信来说这是不允许的，我们可以想象一下，如果我们单片机在通信发送一个字节数据的过程突然暂停了，接收方可是不知道单片机暂停的，接收方会按照原来约定的那个速率进行信号的读取，这就会导致传输出错。所以**异步通信的特点就是非常依赖硬件外设的支持**，必须要有USART电路才能方便地使用，如果没USART硬件电路的支持，那么**串口是很难用软件来模拟的**（虽然说软件模拟也是存在的，但由于异步时序对时钟的要求很严格，所以我们一般很少用软件来模拟串口通信）。

        所以我们要求用同步时序，这样就需要另外加一条**传递时钟的线路**来**指导接收方的读写**，这样由于存在这条时钟线，对传输的时间要求就不高了，单片机也可以随时暂停传输而去处理其他事情，因为暂停传输的同时，时钟线也被暂停了，所以此时通信双方都可以定格在暂停的时刻，可以过一段时间再来继续，不会对传输造成影响，这就是同步时序的好处。

        使用同步时序可以极大地降低单片机对硬件电路的依赖，即使没有硬件电路的支持，也可以很方便地用软件手动翻转电平来实现通信。

        异步时序的好处就是省了一根时钟线，节省资源，缺点就是对时间要求严格，对硬件电路的依赖比较严重；同步时序反之。

        在一些低端的单片机，没有硬件资源的情况下也很容易通过软件来模拟同步时序，缺点就是多一种时钟线，占用了资源。

    有关上面提到的内容具体看视频 [03:30~10:30](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

- SCL通信线的存在使得同步时序得以使用，降低了对硬件的依赖。另外同步的时序也比异步的时序更高
- 一主多从：单片机作为主机，主导I2C总线的运行，挂载在I2C总线上的所有外部模块都是从机，**从机只有被主机点名之后才能控制I2C总线**，不能在未经允许的情况下去碰I2C总线，所有从机可以被动地接收数据，但从机只有在经过主机允许时才能发送数据。**一主多从是I2C绝大部分应用场景下所使用的模式**
- 多主多从：此模式下总线上的任何一个模块都可以主动跳出来并成为主机，但由于同一时间能成为主机的只有一个模块，所以如果有多个主机申请就会发生总线冲突，总线冲突时，I2C协议会进行仲裁，仲裁胜利的一方获得总线控制权，失败的一方自动变为从机

## 硬件电路

> ![image-20230208201229587](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208201229587.png)
>
> 上图是一主多从的I2C通信硬件电路模型

- CPU是主机，主机的权利很大，包括：
    1. 对SCL线的完全控制。任何时候都是主机完全掌控SCL线
    2. 主机可以主动发起对SDA的控制。在空闲状态下，主机可以主动发起对SDK的控制，只有在从机发送数据和从机应答的时候，主机才会转交SDA的控制权给从机
- 从机的权利比较小：
    1. 对于SCL线在任何时候都只能被动读取，从机不允许控制SCL线
    2. 对于SDA数据线，从机不允许主动发起对SDA的控制，只有在主机发送读取从机（也即从机发送数据）的命令或者从机应答的时候后从机才能**短暂**地取得SDA的控制权
- 以上是I2C一主多从模型中协议的规定

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- SCL：主机拥有SCL的绝对控制权，数据流向是主机发送、从机接收，所以主机的SCL可以配置成推挽输出(在一主多从模式下可以，如果是多主多从则需要配置成开漏输出)，所有从机的SCL都配置成浮空输入或上拉输入

- SDA：因为I2C是半双工的协议，所以主机的SDA在发送的时候是输出，接收的时候的输入，同样从机的SDA也会在输入和输出之间反复切换，如果我们能协调好输入输出切换的时机实际上也没有问题，但如果没有协调好，极有可能发生主机和从机都处于输出状态的情况，这种情况下如果主机刚好输出高电平，从机输出低电平，这就会导致I2C总线上流过极大的电流（相当于短路），这种状态是要极力避免的。

    为了避免总线没协调好导致I2C总线短路的这个问题，I2C这样设计：**禁止所有设备输出强上拉的高电平（即不能配置为推挽输出），而采用外置弱上拉加（设备配置为）开漏输出的电路结构**（开漏输出模式有强下拉没有强上拉，即高电平高阻态没有驱动能力，高电平的话语权在外部；低电平低组态有驱动能力，低电平话语权在设备）。这对应了上图中的“设备的SDL和SDA均要配置成开漏输出模式，SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右”(实际上SDL配置成开漏输出是为了服务多主多从模式下的时钟同步和总线仲裁）

- 所有I2C总线上的设备的SCL和SDA接收口的内部结构都是这样的：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208204549502.png" alt="image-20230208204549502" style="zoom:50%;" />
    >
    > 左边一块是SCL的结构（SCLK即SCL），右边一块是SDA的结构（DATA即SDA）

    - 引脚的信号进来时都可以通过一个数据缓冲器（或者是施密特触发器）进行输入，因为**输入对电路没有任何影响**，所以任何设备在任何时刻都是可以输入的

    - 但是在输出的这部分则采用的是开漏输出的配置。

        - 输出低电平时，OUT的MOS开关管导通，引脚直接接地，是强下拉；
        - 输出高电平时，OUT的MOS开关管断开，引脚什么都不接，处于浮空状态

        这样所有的设备都只能输出低电平而无法输出高电平。

        为了在OUT引脚不输出低电平时防止引脚悬空，这时就需要在总线上外置一个上拉电阻：

        > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208221243364.png" alt="image-20230208221243364" style="zoom:50%;" />
        >
        > 通过一个电阻拉到高电平，是弱上拉

### 弹簧案例解释I2C硬件电路工作原理

**弹簧案例类比解释I2C硬件电路见视频 [20:30~22:30](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)**

## I2C时序基本单元

### 起始条件与终止条件

接下来我们学习软件，也就是时序的设计：

> ![image-20230208222344229](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208222344229.png)
>
> I2C总线处于空闲状态时，SCL和SDA都处于高电平状态，也即没有任何一个设备去碰这两根线，此时的高电平是由总线外置的上拉电阻弱上拉上去的

- 起始条件：当主机需要进行数据收发时，SCL保持高电平不去动他，然后把SDA拽下来，产生一个下降沿。当从机捕获到这个SCL高电平，SDA下降沿信号时，就会进行自身的复位，等待主机的召唤

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208223303252.png" alt="image-20230208223303252" style="zoom:50%;" />

    然后在SDA下降沿之后，主机需要再把SCL拽下来。

    把SCL拽下来的目的一方面是为了占用总线，另一方面是为了时序基本单元的拼接（因为我们之后会保证，除了起始和终止条件，每个时序单元的SCL都是以低电平开始，低电平结束，这样这些单元拼接起来SCL才能续得上）：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208224118415.png" alt="image-20230208224118415" style="zoom: 25%;" />
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208224222037.png" alt="image-20230208224222037" style="zoom:25%;" />
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208224140703.png" alt="image-20230208224140703" style="zoom:25%;" />

- 终止条件：SCL先放手让其回弹到高电平，SDA再放手产生一个上升沿，这个上升沿就能触发终止条件，且终止条件后SCL和SDA都是高电平，回到空闲状态：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208224512501.png" alt="image-20230208224512501" style="zoom:50%;" />

    起始条件和终止条件相当于串口通信中的起始位和终止位。

- 另外I2C的起始和终止都是由主机产生，从机不允许产生，所以在总线空闲状态时，从机必须始终双手放开，不允许主动跳出来去碰总线（如果允许的话那就是多主机模型了）

### （主机）发送一个字节

> ![image-20230208224901454](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208224901454.png)

- 起始条件之后的第一个字节必须是由主机发送（应该是为了寻址从机）
- 在SCL低电平期间允许改变SDA的电平，SCL高电平期间就不允许了！
- 通常情况下再SCL上升沿期间从机就将SDA上的数据读走了
- 高位先行指的是发送的第一位数据是一个字节的最高位B7，最后一位是最低位B0

此部分内容见视频 [24:40~27:50](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

### （主机）接收一个字节

> ![image-20230208225602181](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208225602181.png)

- 主机在接收前需要释放SDA。因为主机释放SDA就相当于切换到了接收/输入的模式（就好比放手看着别人操作SDA），我们可以理解为所有设备实际上都处于接收/输入模式，当需要发送的时候就要去主动拉SDA，之所以要释放就是为了避免影响从机发送数据

- 上图中实现部分表示主机控制：
    - 注意此时SCL的控制权仍然在主机上，因为从机不确定下一次SCL高电平又是什么时候，所以一般情况下都会在SCL下降沿的瞬间变换SDA
    - 主机可以在SCL高电平的任意时刻读取SDA数据

此部分内容见视频 [27:50~30:00](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

### 发送&接收应答

> ![image-20230208231042841](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208231042841.png)

- 应答的时序分别与发送一个字节和接收一个字节的其中一位相同：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208231145948.png" alt="image-20230208231145948" style="zoom: 25%;" />

- 发送一个字节之后就要紧跟着调用接收应答的时序：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208231557522.png" alt="image-20230208231557522" style="zoom:50%;" />

    有关接收应答时序的举例讲解见 [31:10~31:45](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

- 发送应答存在的目的是为了告诉从机：你是不是还要继续发？如果从机发送了一个数据后并且得到了主机的应答，那么从机就会继续发送：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208231933127.png" alt="image-20230208231933127" style="zoom:25%;" />

    如果从机没有得到主机的应答，那么从机就会认为：啊，我发送了一个数据，但是主机不理我，可能主机不想要了吧，这时从机就会乖乖地释放SDA，交出SDA的控制权以防止干扰主机之后的操作

## I2C时序

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208232425973.png" alt="image-20230208232425973" style="zoom:50%;" />

由于一主多从的模型下，主机可以访问总线上的任何一个设备，那么如何发出指令来确定要访问哪一台设备呢？这就需要利用从机设备的唯一设备地址了：

1. 主机在起始条件后，要先发送一个字节叫一下从机名字（即设备地址）
2. 此时所有从机都会收到这第一个字节，并和自己的设备地址进行比较
    1. 如果地址不同则认为主机没有叫我，之后的时序我就不管了
    2. 如果一样就说明主机现在在叫我，那么就响应主机之后的读写操作

### 指定地址写

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230208232842548.png" alt="image-20230208232842548" style="zoom:50%;" />

- Slave Address：从机地址
- Reg Address：从机内部的寄存器地址
- Data：写入该寄存器的数据

> ![image-20230209001829266](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209001829266.png)
>
> 起始条件后紧跟主机发送一个字节，字节的内容必须是从机地址+读写示意位。
>
> 正好从机地址是7位，读写位是1位，加起来一个字节8位
>
> 发送从机地址就是确定通信对象
>
> 发送读写位就是确认接下来的操作是要写入还是要读出，0表示主机将进行写入操作，1表示读取

> ![image-20230209102850323](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209102850323.png)
>
> 第一个字节并且在收到应答位RA:0之后，第二个字节的内容就可以送到指定设备的内部了。
>
> 从机可以自主定义第二个字节和后续字节的用途：一般第二个字节可以是寄存器地址或指令控制字等（例如MPU6050的第二个字节就是寄存器地址，AD转换器第二个字节可能就是指令控制字，存储器第二个字节就是存储器地址）
>
> 这里就是在告诉MPU6050：我要操作你0001 1001级0x19地址下的寄存器
>
> 接着后面也跟着一个从机的应答位RA:0

> ![image-20230209103309343](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209103309343.png)
>
> 最后一个字节就是主机要写入到MPU6050的0x19地址下寄存器的内容了，这里要写入的就是1010 1010即0xAA
>
> 再随后是从机的接收应答位RA:0
>
> 如果主机再不需要传输了，就可以产生一个终止时序P

所以上述案例的操作就是：对从机地址为1101 000的从机，执行写操作0，在其内部地址为0x19的寄存器写入0xAA

此部分内容见视频 [35:15~41:30](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

### 当前地址读

> ![image-20230209104046295](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209104046295.png)
>
> 在从机应答RA：0开始，SDA的控制权转交至从机，后面Receive Byte实际上是从机在发送。
>
> 这里在主机发送读的时序后，紧跟着就把SDA控制权交给从机，主机还没有指定从机的地址，那么从机后续所发送的这个字节内容是哪个寄存器的呢？——当前地址指针：
>
> 在从机中所有的寄存器被分配到了一个线性区域，并且会有一个单独的指针变量指示其中的一个寄存器：
>
> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209105216360.png" alt="image-20230209105216360" style="zoom:25%;" />
>
> 这个指针上点时默认指向0地址，并且每写入和读出一个字节后这指针就会自动++移动到下一个位置：
>
> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209105305111.png" alt="image-20230209105305111" style="zoom:25%;" />
>
> 那么在调用当前地址读时序时，主机没有指定要读哪个地址，从机就会返回当前指针所指向的寄存器内的值。
>
> 假设我们刚才调用了指定地址写的时序，在0x19写入了0xAA，那么这个时序完成之后指针自增到了0x1A的位置，此时我们再调用当前地址读的时序，返回的就是0x1A寄存器的内容，接着再调用就是0x1B寄存器的内容，以此类推...
>
> 最后主机接收不应答SA：1，表示主机接收停止，此时SDA控制权回到主机（自己说的。。。这样说对吗？？?），随后主机发起终止条件P

对从机地址为1101 000的从机，执行读操作1，在从机的当前寄存器地址读取到内容0x0F

此部分内容见视频 [41:30~44:50](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

### 指定地址读

> ![image-20230209105914521](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209105914521.png)
>
> 这个时序的前半部分是指定地址写，后半部分是当前地址读，组合起来就是指定地址读

> 首先我们看前半部分，即指定地址写：
>
> ![image-20230209110246171](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209110246171.png)
>
> 第一个字节0xD0：前7位是从机地址，最后一位0表示要执行写操作，随后从机应答RA：0
>
> 第二个字节0x19：用来指定从机寄存器地址，这个0x19就是写入到从机的地址指针变量里了，也就是说从机在接收到第二个字节0x19之后，它的寄存器指针就指向了0x19寄存器，随后从机应答RA：0
>
> 之后本来应该第三个字节发送要写入的内容，但是我们这里直接再来了一个起始条件Sr（Start Repeat重复起始条件），相当于另起了一个时序

> 因为我们最终要执行的是读操作，但由于前面为了寻址执行了指定地址写的时序（发送的第一个字节的最后一位为0），此时我们为了变换写为读，所以要再另起这个时序来转换写为读：
>
> 后半部分，即当前地址读：
>
> ![image-20230209110945234](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209110945234.png)
>
> 再重复起始条件Sr后第一个字节重新寻址，并指定读写标志位为1，表示要进行读操作，随后从机应答RA:0`
>
> 接着主机将SDA控制权转交从机，从机发送当前地址（这个当前地址是在前半部分指定地址写的时序中给定的）寄存器的内容0xAA给主机，随后主机应答SA：1表示停止接收并发起终止条件P

另外其实在前半部分指定地址写只有也可以增加一个终止条件P：

> ![image-20230209111954042](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209111954042.png)

在前半部分指定地址写所给寄存器指针指定的地址不会因为这个终止条件而消失。但是I2C协议官方规定是没有在中间加入这个终止条件的。

此部分内容见视频 [44:50~47:30](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

### 指定地址写入多个字节

> 下面是指定地址写（一个字节）的时序图
>
> ![image-20230209112329293](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209112329293.png)

如果我们想要写入1个字节，就在指定地址写的时序后跟一个P；但如果我们想写入多个字节就先不要给P，而是重复最后Send Byte要写入的内容（如上图红框所示，例如要写入3个字节），当然一个字节后要紧跟一个RA：0，这样就会发送给从机的寄存器这三个字节，并且在这个过程中寄存器指针不断自增，这三个字节就被按顺序写入到从机三个连续的寄存器中了。

### 当前地址读、指定地址读多个字节

该部分操作与上面“指定地址写入多个字节”类似，就是重复后面的几个字节，但是要注意读多个字节的话应该要让主机的接收应答SA给0，即SA：0，这样才表示主机要连续接收/读取多个字节，当主机不想接收了才给应答SA：1。

- 即主机应答SA：1，从机就会停止发送，并把SDA控制权还给主机；
- 如果主机应答SA：0，从机会认为主机还想要数据，就会继续发送发一个数据

从机控制SDA的发送一个字节的权利开始于读写标志位为1，结束于主机应答1：

> ![image-20230209113313878](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\7 通信\Note\image-20230209113313878.png)

在等待主机应答的瞬间，SDA的控制权回到主机。

读写多个字节的内容见视频  [47:30~End](https://www.bilibili.com/video/BV1th411z7sn?p=31&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)