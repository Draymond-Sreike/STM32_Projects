# 中断

> ![image-20230130163526035](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130163526035.png)
>
> **中断触发条件（中断源）**可以是：
>
> 1. 引脚发生电平跳变
> 2. 定时器定时时间结束
> 3. 串口通信接收到了数据
>
> 这些事件的共同特点是，这些事件发生时，情况会比较紧急，如果没有及时处理这些事件，下一个事件信号就又来了（例如串口接收中断来了，如果不来及时读取接收到的数据，那下一个数据再过来时就会把原来的数据覆盖掉）。
>
> 如果没有中断系统，为了防止外部中断被忽略（例如串口数据被覆盖），那么主程序就只能不断查询是否有这些事件发生，而干不了其他的事情了（例如如果没有定时器中断，那主程序只能依靠delay函数才能实现定时的功能），有了中断系统后，主程序就可以放心执行其他事情，有中断的时候再取处理即可（这就好比我们早上定了一个闹钟，定好之后就可以安心睡觉了，时间到了闹钟会提醒我们，这就相当于产生了一个中断信号，如果我们没有闹钟，我们就得不断地看时间，看会不会错过了起床的时间点，这样的话我们岂不是就没办法安心睡觉了）。
>
> **中断优先级**是为了在有多个中断同时申请时，用于判断应该先处理执行哪一个中断。如果事件非常紧急，我们就把优先级设置得高一点，如果不是那么紧急就可以设置低一些，这样可以更好地安排这些中断事件，防止紧急的事件被别的中断耽误。
>
> **中断嵌套**简而言之就是把中断程序再次中断的现象。中断嵌套也是为了照顾非常紧急的中断而产生的。能否产生中断嵌套也是由中断的优先级所决定的。

## 中断执行流程

> ![image-20230130165351996](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130165351996.png)

- 中断来临的时候，主程序会立即暂停，程序将由**硬件电路**自动跳转到中断程序。

- 为了程序能在中断返回后继续原来的工作，在断点处执行中断前，程序会**对现场进行保护**，中断执行完成后会再还原现场，这样可以保证主程序即使被中断了，回来之后也能继续运行。当然我们用C语言编程，保护现场和还原现场的工作并不需要我们来做，编译器已经帮我们做好了。
- 一般中断程序都是在一个子函数里的，这个函数不需要我们调用，当中断来临时，由硬件自动调用这个函数，这就是在C语言中，中断的执行流程。 、

## STM32的中断资源

> ![image-20230130170339085](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130170339085.png)

- 68个可屏蔽中断通道：中断通道即中断源，STM32有68个中断源（这是F1系列最多的中断数量，对于具体的型号可能没有这么多中断，具体数量以对应型号的数据手册为准）
- EXIT外部中断、TIM定时器、ADC模数转换器、USART串口、SPI通信、I2C通信、RTC实时时钟。
- NVIC是STM32用来管理中断、分配优先级的，共有16个等级，还可以设置抢占优先级和相应优先级
- 每个中断通道都拥有16个优先级，这是由于NVIC分配了4个优先级寄存器，我们还可以通过程序对这个优先级划分为抢占优先级和响应优先级，并决定要划分多少个寄存器用于配置抢占优先级和响应优先级，详细内容见下一小节的“NVIC优先级分组”

上图中右图的灰色部分是内核的中断，白色部分即是STM32外设的中断：

> ![image-20230130170916992](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130170916992.png)
>
> 1. 例如WWDG（窗口定时器中断），我们也称窗口看门狗，这个是用来监测程序运行状态的中断，例如程序卡死了，没有及时喂狗，窗口看门狗就会申请中断，这时我们的程序就会跳转到窗口看门狗的中断程序里，我们此时就可以在中断程序里进行一些错误检查
> 2. PVD（电源电压检测），如果供电电压不足，PVD电路就会申请中断，在中断里就可以知道现在是供电不足，电池快要没电了，可以执行保存数据的程序。
>
> 这些中断资源的右侧都附写有地址：这是因为我们程序中的中断函数的地址是由编译器来分配的，是不固定的，但是我们的中断跳转**由于硬件的限制**，只能跳到固定的地址执行程序，所以为了让硬件跳转到一个地址不固定的中断函数里，就需要在内存中定义一个存放（中断函数）地址的列表（我们称为向量表），这个列表用来存放不固定的中断函数的地址，但是列表本身的地址是固定的（也就是上图中表格右侧所示的地址）。中断发生时程序就会跳转到这个表里（上图中表格右侧所示的地址），然后在表里读取到对应的中断函数的地址后由编译器自动加上一条跳转到中断函数的代码，这样中断跳转就可以跳转到存放在任意位置的中断函数了并执行了。
>
> 示意图如下：
>
> ![image-20230130174104079](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130174104079.png)
>
> - 图中蓝色框部分表示中断向量表，存放中断函数的地址
> - 绿色部分表示中断跳转流程
>
> 存放中断函数地址的列表称为**中断向量表**。相当于中断跳转的一个跳板，我们用C语言编程是不需要管这个表的，编译器都帮我们做好了跳转的工作。

**我们要学习的就是EXTI中断**：	

> ![image-20230130171635073](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130171635073.png)

## NVIC基本结构

NVIC：嵌套中断向量控制器，在STM32中用来统一分配和管理中断，是一个内核外设，CPU的“小助手”

> ![image-20230130201330237](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130201330237.png)
>
> n表示一个外设（如EXTI，TIM...）可能会占用多个中断通道，所以这里有n条线。
>
> NVIC只有一个输出口，其根据每个中断的优先级分配中断的先后顺序，之后通过这个输出口告诉CPU该处理哪个中断。用医院的例子来理解就是CPU是医生，NVIC就是医院的叫号系统。

另外由于NVIC是内核外设，所以NVIC的相关资料要在Cortex-M3的编程手册里找：

> ![image-20230201110530479](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201110530479.png)
>
> 这个编程手册就是STM32内核和内核外设的详细介绍。

### NVIC优先级分组

> ![image-20230130202300391](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130202300391.png)

- 决定能否中断嵌套的优先级称为抢占优先级，抢占优先级高的可以进行中断嵌套。

- 优先级的值越小，优先级越高，0是最高优先级。

- 抢占优先级和响应优先级均相同的按中断号排队。中断号如下图：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130204349516.png" alt="image-20230130204349516" style="zoom:50%;" />

    中断号小的优先响应。

- 由于优先级寄存器总共有4位，于是分配给抢占优先级和响应优先级的寄存器个数组合可以是(4,0)、(3,1)、(2,2)、(1,3)、(0,4)，这个分组的方式在程序中是由我们来配置的。

    选好分组方式之后，我们在配置优先级的时候就要注意抢占优先级和响应优先级的取值范围了，不要超出上上个表中所示的取值。

- STM32不存在先来后到的排队方式，在任何时候都是优先级高的先响应。

关于抢占优先级和响应优先级以及NVIC基本结构的讲解见视频 [12：00~17:00](https://www.bilibili.com/video/BV1th411z7sn/?p=11&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

### NVIC程序配置步骤

1. 指定中断分组NVIC_PriorityGroupConfig；
2. NVIC_Init。

### NVIC相关函数

由于NVIC是内核外设，所以其函数相关声明被分配到了misc.h这个杂项文件中了：

> ![image-20230201144909174](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201144909174.png)

其中：

1. > ![image-20230201144933335](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201144933335.png)

    是用来中断分组的，参数是中断分组的方式。

    - 参数配置参考如下：

        > ![image-20230201145334293](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201145334293.png)
        >
        > pre-emption priority：先占优先级、抢占优先级；
        >
        > subpriority：从占优先级、响应优先级。

        一般在中断不多的情况下，很难导致中断冲突，此时对于优先级分组来说就可以比较随意了，选择哪一种分组方式都行。我们可以选择(2, 2)的分组方式：

        > ![image-20230201145641210](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201145641210.png)

        另外注意一下：这个分组的方式整个芯片只能用一种，所以按理说上图所示的这个分组的代码在整个工程只需要执行一次即可，如果我们把它放在模块里进行分组（例如我们所写的多个外设的Init函数都需要配置中断的情况），我们还要确保每个模块的分组方式都是同一个。否则**我们也可以把这句代码放在主函数的最开始**，这样每个模块也就都不用再重复写这一句代码了。

2. > ![image-20230201145004542](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201145004542.png)

    类似GPIO_Init。

    该结构体的参数：

    > ![image-20230201150135203](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201150135203.png)

    - **NVIC_IRQChannel**：

        > ![image-20230201150201734](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201150201734.png)
        >
        > 指定中断通道来开启或关闭。
        >
        > IRQ_Type：
        >
        > ![image-20230201150344057](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201150344057.png)
        >
        > 由于后续我们程序要用到PB14，连接的通道是EXTI14，所以这里选择EXTI15_10_IRQn（10~15的通道都包含在这里）。
        >
        > 最终配置代码：
        >
        > ![image-20230201150550619](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201150550619.png)

    - **NVIC_IRQChannelCmd**：

        > ![image-20230201150712575](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201150712575.png)
        >
        > 指定中断通道是使能还是失能。
        >
        > 配置完成后：
        >
        > ![image-20230201150739627](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201150739627.png)

    - **NVIC_IRQChannelPreemptionPriority：**抢占优先级配置

    - **NVIC_IRQChannelSubPriority：**响应优先级配置

        > ![image-20230201151822066](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201151822066.png)
        >
        > 我们根据我们前面所配置的分组方式，需要参考对应的取值范围：
        >
        > ![image-20230201152203589](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201152203589.png)
        >
        > Find：
        >
        > ![image-20230201152217180](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201152217180.png)
        >
        > 由于我们前面选择了Group2，所以取值范围就对应如上图。
        >
        > 因为我们程序的中断只有一个，所以优先级的配置是可以随意的，只有在多个中断源同时申请，产生拥挤时才有作用，这里暂时不需要。
        >
        > 最终配置如下：
        >
        > ![image-20230201152401782](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201152401782.png)

        最终NVIC的配置程序如下：

### NVIC配置程序示例

> ![image-20230201152537836](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201152537836.png)



1. > ![image-20230201145030008](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201145030008.png)

    设置中断向量表。

2. > ![image-20230201145050660](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201145050660.png)

    系统低功耗配置。

一般中断多只需要用到前两个函数即可。配置步骤如下

1. 



## EXTI

> ![image-20230130205106126](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130205106126.png)

- 软件触发：引脚啥事都不用干，程序里执行一句代码就可以触发中断。

- 相同的Pin不能同时触发中断：这个意思就是例如PA0和PB0不能同时用，或者PA1、PB1、PC1这样的GPIO_Pin一样的，只能选1个作为中断引脚。

    所以如果我们有多个IO口要作为中断引脚，要选择不同Pin的引脚，例如PA6和PA7、PA9和PB15、PB0和PB1。

- 通道数有16个GPIO_Pin，这对应的是GPIO_Pin_0到GPIO_Pin_15

    外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒，加上16个GPIO_Pin总共约20个中断通道/中断线路

    其中16个GPIO_Pin是外部中断的主要功能，而后面外加的这几个实际上是来“蹭网”的，为啥要来蹭网呢？因为这个外部中断有一个功能，就是从低功耗的停止模式下唤醒STM32

    - 对于PVD电源电压监测，当电源从电压过低恢复时，就需要PVD借助一下外部中断退出停止模式
    - 对于RTC闹钟来说，有时候为了省电，RTC定一个闹钟之后，STM32会进入停止模式，等到闹钟响的时候再唤醒，这也需要借助外部中断
    - 另外USB唤醒、以太网唤醒也都是类似的作用。

    当然我们学习的重点落在16个GPIO_Pin的外部中断，外加的4个中断我们了解一下即可。

- 触发响应方式：中断响应/事件响应。

    - 中断响应：申请中断，让CPU执行中断函数。
    - 事件响应：当外部中断检测到引脚电平变化时，选择触发一个事件，此时外部的中断信号不会通向CPU，而是通向其他外设，用来触发其他外设的操作，例如触发ADC转换，触发DMA等等。

    总结就是：中断响应是正常的流程——引脚电平触中断；事件响应不会触发中断，而是触发别的外设操作，属于外设之间的联合工作。

### EXTI基本结构***

> ![image-20230130213204298](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130213204298.png)

- GPIOA、B、C都是GPIO口的外设，每个外设有16个引脚，所以有16根线

- PA0、PB0、PC0这些通过AFIO中断引脚选择的电路模块（这是一个数据选择器，可以选择GPIO的引脚连接到后面与EXIT连接的通道上）选择之后，这三个只有其中一个能接到与EXTI相连接的通道0上，其他Pin也是同理。

- 通过AFIO选择后的16个通道，就接到了EXTI边沿检测及控制电路上，下面4个“蹭网”的外设也是并列接进来的。这些加起来就组成了EXTI的20个输入信号。

- 经过EXTI电路之后就分为了两种输出，**一种输出就接到了NVIC**来触发中断。另外本来20路EXTI输入应该对应20路输出，但是这里EXTI5~9、EXTI15_10的输出是合并5~9、10~15合成一路，此时外部中断5~9会触发同一个中断函数，10~15也只会触发同一个中断函数，所以我们在编程的时候，我们**在这两个中断函数里需要再根据标志位来区分到底是哪个中断进来的**。

    **另一种输出接到了其他外设**，用来触发其他外设操作，也就是上面所说的事件响应。

### EXTI框图

> ![image-20230130215331540](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215331540.png)

- 右下脚的“输入线”表示20根输入线，输入线先进入边沿检测电路，上面的上升沿触发选择寄存器、下降沿触发选择寄存器可以选择是上升沿触发、下降沿触发或者同时触发。

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215601585.png" alt="image-20230130215601585" style="zoom:50%;" />

- 接着触发信号就进入到了这个或门的输入端了（关于门电路的知识可以翻看后面关于门电路的讲解），如下图

    > ![image-20230130215659711](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215659711.png)

    此时软件触发（软件中断事件寄存器）和硬件触发（边缘检测电路的输出）都接到了这个或门上，也就是二者只要任意一个为1，或门输出就为1。

- 触发信号通过上面这个或门后就兵分两路，上面一路是用于**触发中断**的，下面一路是用于**触发事件**的，如下图

    > ![image-20230130221215023](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221215023.png)

    触发中断首先会置一个请求挂起寄存器，这相当于一个中断标志位，我们可以读取这个寄存器来判断是哪个通道触发的中断，如下图：

    > ![image-20230130221314702](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221314702.png)

    如果中断挂起寄存器置1，它就会继续往左走，和中断屏蔽寄存器进入一个与门，然后进入NVIC中断控制器，如下图

    > ![image-20230130221406617](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221406617.png)
    >
    > 这里的与门实际上相当于一个开关，因为对于与门来说：1与上任意数x，输出就是这个任意数x；0与上任意数x，输出始终为0，如下图所示：
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221551245.png" alt="image-20230130221551245" style="zoom:50%;" />
    >
    > 如果中断屏蔽寄存器给1，那么请求挂起寄存器的输出就可以直接通向NVIC中断控制器，也就是允许中断，如下图：
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221649228.png" alt="image-20230130221649228" style="zoom:50%;" />
    >
    > 如果中断屏蔽寄存器给0，那么请求挂起寄存器的输出无论是什么，给到NVIC中断控制器的输入都是0，相当于屏蔽了中断，如下图：
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221728877.png" alt="image-20230130221728877" style="zoom:50%;" />

    另一个触发事件的部分，如下图所示：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221954289.png" alt="image-20230130221954289" style="zoom: 67%;" />
    >
    > 首先也是通过一个事件屏蔽寄存器进行开关控制，然后通过一个脉冲发生器到其他外设。
    >
    > 这里的脉冲发生器就是给一个电平脉冲，用来触发其他外设的动作。

- 另外框图上半部分的20表示的是20根线，代表20个通道，如下图所示：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130222158274.png" alt="image-20230130222158274" style="zoom: 67%;" />

- 如上图所示，框图最上面我们还可以看到外设接口和APB总线，我们可以通过总线访问这些寄存器。

### EXTI相关函数（配置EXTI）

1. > ![image-20230201114609970](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201114609970.png)

    把EXTI的配置均予以清除，恢复成上电默认状态。

2. > ![image-20230201114655822](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201114655822.png)

    类似GPIO_Init，可以根据结构体里的参数配置EXTI外设。这是初始化EXTI主要使用的函数。

3. > ![image-20230201114829548](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201114829548.png)

    这个函数可以把传入的结构体赋一个默认值，即配置所传入的结构体的参数。

4. > ![image-20230201115021519](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201115021519.png)

    软件触发外部中断，调用这个函数，参数给一个指定的中断线，就能软件触发一次这个外部中断。在程序中如果需要这个功能，可以使用这个函数，如果只需要外部引脚触发中断，就不需要用这个函数了。

    

因为在外设运行的过程中会产生一些状态标志位，例如外部中断来了，挂起寄存器会置一个标志位，又如串口外设接收到数据，也会置标志位，定时器时间到了也会置标志位，这些标志位都是放在状态寄存器的，当程序想要看这些标志位时，就可以用到下面的这些函数（当然这是对于EXTI外部中断来说的，其他外设有其他外设的函数）：

1. > ![image-20230201121503115](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201121503115.png)

    获取指定的标志位，用于查看其是否被置1了。

2. > ![image-20230201121534708](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201121534708.png)

    可以对置1的标志位进行清除。

如果有些标志位比较紧急——在置标志位后会触发中断，**在中断函数里**，如果我们想查看标志位和清除标志位，就用下面这两个函数：

1. > ![image-20230201121721827](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201121721827.png)

    获取中断标志位是否被置1。

2. > ![image-20230201121746325](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201121746325.png)

    清除中断挂起标志位。

以上总结就是：

- 如果我们想在主程序中查看和清除标志位，就使用这四个函数中的前两个函数
- 如果想在中断函数里查看和清除标志位，就用后两个函数

本质上这四个函数都是对**状态寄存器**的读写，只不过后两个函数只能读写与（触发）中断有关的标志位，并且对中断是否允许做出了判断；而前两个函数只是一般的读写标志位，没有额外的处理，能不能触发中断的标志位都能读取。

所以我们建议在主程序中使用前两个函数，中断程序里使用后两个函数。当然如果非要在中断程序中用前两个函数也是没有问题的。前后的两个函数只不过是库函数针对这两种场景区分了这两类读写函数罢了

### EXTI配置程序示例

> ![image-20230201122543190](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201122543190.png)
>
> 以上程序的配置是在打通从EXTI到NVIC之间的通路。
>
> 其中在配置结构体参数EXTI_Line时如果有多条Line可以通过或的方式：
>
> ![image-20230201210841224](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201210841224.png)



## AFIO

> ![image-20230130214529982](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130214529982.png)

上图中右边的小图就是AFIO选择中断引脚的结构图。它可以选择GPIOx的某一个Pin接到EXTI上。如下图所示：

> ![image-20230130214745537](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130214745537.png)
>
> 梯形部分所示的就是一个数据选择器。

### AFIO相关函数（配置AFIO）

AFIO的配置函数声明在与GPIO相同的.h文件里。

1. > ![image-20230201113108186](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201113108186.png)

    这个函数用来复位AFIO外设，调用这个函数：AFIO外设的配置就会全部清楚。

2. > ![image-20230201113417849](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230201113417849.png)

    这两个函数是用来配置AFIO的事件输出功能的。

3. > ![image-20230201113517061](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230201113517061.png)

    - GPIO_PinRemapConfig可以用来进行引脚重映射
        - 第一个参数选择重映射的方式
        - 第二参数是新的状态
        
    - GPIO_EXTILineConfig可以配置AFIO的数据选择器，以此来选择我们想要的中断引脚，即想要的Pin

        如果有多个引脚，我们不采用或的方式，而采用下面这种方式：

        > ![image-20230201205435611](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201205435611.png)
        >
        > 即调用两次函数。
        >
        > 注意这里函数的第二个参数GPIO_PinSource的选择是相当于在配置哪个数据选择器有效，如下图所示，如果选择GPIO_PinSource1，则整个Pin1到EXTI1的线路就都打通了，即下图中的第二个数据选择器整个都是闭合状态（但此时A到G所有的Pin都有效，但生效只能有一个GPIOx的Pin，这个取决于我们前面配置的GPIO哪个的输入是有效的）。
        >
        > ![image-20230130214745537](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130214745537.png)

4. > ![image-20230201113723375](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230201113723375.png)

    与以太网有关。（有些芯片没有以太网，可能用不上，像我们目前所学型号的32就没有）

## 使用外部中断的模块特性

对于STM32来说，想要获取的信号是外部驱动的很快的突发信号，例如**旋转编码器**的输出信号，我们可能很久都不会拧动它，这时不需要32对编码器做任何事情，但是我们一旦拧动它，就会有很多脉冲信号需要32接收，这个信号是突发产生的，32也不知道什么时候会来，同时这个信号是外部驱动的（即外部产生的），所以32只能被动读取，并且这个脉冲信号非常快，32稍微晚一点来读取就会错过很多波形。

对于上述所描述的这种情况，就可以考虑使用STM32的外部中断了。有脉冲过来，32立即进入中断函数进行相应处理，没有脉冲的时候32就安心做其他事情。

类似旋转编码器的读取，**红外接收头**的读取也是类似这样的情况。

另外对于**按键**，虽然按键的动作也是外部驱动的突发事件，但并**不推荐使用外部中断来读取按键**，因为外部中断不好处理按键的抖动和松手检测问题，并且对于按键来说，它的输出波西也并非转瞬即逝的，所以**在要求不高的情况下可以在主程序中循环读取**，若不想使用主循环读取也可以**考虑采用定时器中断读取**的方式，**这样既可以做到后台读取按键值、不阻塞主程序，也可以很好地处理按键抖动和松手检测的问题**。

## 配置外部中断的步骤

> ![image-20230201111739327](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201111739327.png)

配置外部中断简单来说，就需要把这个中断信号从GPIO到NVIC这一路出现的模块都配置好，把中断信号的道路给打通即可（如上图所示），具体步骤如下：

1. 配置RCC，把涉及的外设的时钟打开

    - 只需要配置GPIO和AFIO的时钟，EXTI和NVIC的时钟是默认打开的。EXTI不知道为什么不需要，但是NVIC是因为其是内核外设，内核外设均是不需要我们来开启时钟的，RCC管的是内核外的外设。

2. 配置GPIO，选择端口为输入模式

    - 对于外设引脚都需要配置什么样的方式可以在手册中查询：

        > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201112711836.png" alt="image-20230201112711836" style="zoom:50%;" />

        对于EXTI，可以看到其推荐配置如下：

        > ![image-20230201112807584](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201112807584.png)

        

3. 配置AFIO，选择我们所用的GPIO连接到后面的EXTI

4. 配置EXTI，选择边沿触发方式还有触发响应方式（中断/事件响应，一般是用中断响应）

5. 配置NVIC，给中断选择一个合适的优先级

这样中断信号就能进入CPU了，32就会跳转到中断函数中执行中断程序。

## 配置外部中断的示例程序

> ![image-20230201152625651](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201152625651.png)
>
> ![image-20230201152638152](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201152638152.png)

这样外部中断信号就能顺利从GPIO、AFIO、EXTI再到NVIC最终通向CPU了。最终CPU就会由主程序跳到中断程序执行，中断程序的就写在我们对应的中断函数里：

# 中断函数

在STM32中，中断函数的名字都是固定的，每个中断通道都对应有一个中断函数，中断函数的名字我们可以从启动文件中得到：

> ![image-20230201153042766](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201153042766.png)
>
> 这其中以IRQHandle结尾的字符串就是中断函数的名字。
>
> 然后我们使用的中断函数如下：
>
> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201153243932.png" alt="image-20230201153243932" style="zoom:50%;" />
>
> 这就是中断函数的格式，中断函数都是无参无返回值的，中断函数的名字不要写错，写错是无法进入中断的（最好是直接从启动文件copy过来）。
>
> 另外由于10_15的通道是合在一起了，为了判断是否是指定的Line14触发中断，我们首先要在中断程序中进行中断标志位的判断，乳如下图第37行代码所示，最后还需要清除中断标志位，不能让中断标志位一直处于SET状态，否则这个中断源就会一直申请中断，这样会导致程序不断响应中断，执行中断函数，从而导致程序卡死在中断函数里，所以每次中断函数执行完成的最后一步都需要清除一下中断标志位）
>
> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201211514646.png" alt="image-20230201211514646" style="zoom:50%;" />
>
> 另外如果中断是有单独函数的，不像上面的函数一样是10和15复用一个函数的，可以不用判断中断标志位，但为了规范我们还是写一下：
>
> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230201211147262.png" alt="image-20230201211147262" style="zoom:50%;" />

## 中断函数编程建议

1. 中断函数中不要执行耗时过长的代码，中断函数要简短快捷（不要在中断函数中用Delay）

2. 不要在中断函数和主函数调用相同的函数或操作同一个硬件，尤其是硬件相关的函数，比如OLED显示（如果在主函数中调用OLED函数，中断函数也调用，那么会导致OLED显示出错）。

    在实现功能时，可以先在中断函数里操作变量或标志位，当中断执行完成返回主函数后再对这个变量或标志位进行显示或操作。这样能保证中断函数的简短快速，又能保证不产生冲突的硬件操作。

    在其他地方我们也可以多用变量和标志位，仅使用变量或标志位作为接口，以此来减少代码的耦合性，让各代码间相互独立，这样能让程序更加清晰，代码更加健壮。

    此部分内容的讲解见视频 [47:00~](https://www.bilibili.com/video/BV1th411z7sn/?p=12&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

# 门电路

## |或门

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215749994.png" alt="image-20230130215749994" style="zoom:50%;" />

- 或门可以有多个输入，但只有一个输出
- 在输入端只要有一个是高电平1，则输出就是高电平
- 只有输入全部为0，输出才为0

## &与门

> ![image-20230130215954148](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215954148.png)

- 与门可以有多个输入，但只有一个输出

- 在输入端只要有一个是低电平0，输出就是0

- 只有输入全部为1，输出才为1

## !非门

> ![image-20230130220152266](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130220152266.png)

- 非门只有一个输入一个输出
- 输入1输出0
- 输入0输出1

# 数据选择器

> 、![image-20230130220507919](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130220507919.png)

- 数据选择器有多个输入，一个输出
- 侧面有选择控制端，根据控制端的数据，可以从输入选择一个输入接到输出