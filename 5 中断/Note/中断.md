# 中断

> ![image-20230130163526035](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130163526035.png)
>
> **中断触发条件（中断源）**可以是：
>
> 1. 引脚发生电平跳变
> 2. 定时器定时时间结束
> 3. 串口通信接收到了数据
>
> 这些事件的共同特点是，这些事件发生时，情况会比较紧急，如果没有及时处理这些事件，下一个事件信号就又来了（例如串口接收中断来了，如果不来及时读取接收到的数据，那下一个数据再过来时就会把原来的数据覆盖掉）。
>
> 如果没有中断系统，为了防止外部中断被忽略（例如串口数据被覆盖），那么主程序就只能不断查询是否有这些事件发生，而干不了其他的事情了（例如如果没有定时器中断，那主程序只能依靠delay函数才能实现定时的功能），有了中断系统后，主程序就可以放心执行其他事情，有中断的时候再取处理即可（这就好比我们早上定了一个闹钟，定好之后就可以安心睡觉了，时间到了闹钟会提醒我们，这就相当于产生了一个中断信号，如果我们没有闹钟，我们就得不断地看时间，看会不会错过了起床的时间点，这样的话我们岂不是就没办法安心睡觉了）。
>
> **中断优先级**是为了在有多个中断同时申请时，用于判断应该先处理执行哪一个中断。如果事件非常紧急，我们就把优先级设置得高一点，如果不是那么紧急就可以设置低一些，这样可以更好地安排这些中断事件，防止紧急的事件被别的中断耽误。
>
> **中断嵌套**简而言之就是把中断程序再次中断的现象。中断嵌套也是为了照顾非常紧急的中断而产生的。能否产生中断嵌套也是由中断的优先级所决定的。

## 中断执行流程

> ![image-20230130165351996](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130165351996.png)

- 中断来临的时候，主程序会立即暂停，程序将由**硬件电路**自动跳转到中断程序。

- 为了程序能在中断返回后继续原来的工作，在断点处执行中断前，程序会**对现场进行保护**，中断执行完成后会再还原现场，这样可以保证主程序即使被中断了，回来之后也能继续运行。当然我们用C语言编程，保护现场和还原现场的工作并不需要我们来做，编译器已经帮我们做好了。
- 一般中断程序都是在一个子函数里的，这个函数不需要我们调用，当中断来临时，由硬件自动调用这个函数，这就是在C语言中，中断的执行流程。 、

## STM32的中断资源

> ![image-20230130170339085](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130170339085.png)

- 68个可屏蔽中断通道：中断通道即中断源，STM32有68个中断源（这是F1系列最多的中断数量，对于具体的型号可能没有这么多中断，具体数量以对应型号的数据手册为准）
- EXIT外部中断、TIM定时器、ADC模数转换器、USART串口、SPI通信、I2C通信、RTC实时时钟。
- NVIC是STM32用来管理中断、分配优先级的，共有16个等级，还可以设置抢占优先级和相应优先级
- 每个中断通道都拥有16个优先级，这是由于NVIC分配了4个优先级寄存器，我们还可以通过程序对这个优先级划分为抢占优先级和响应优先级，并决定要划分多少个寄存器用于配置抢占优先级和响应优先级，详细内容见下一小节的“NVIC优先级分组”

上图中右图的灰色部分是内核的中断，白色部分即是STM32外设的中断：

> ![image-20230130170916992](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130170916992.png)
>
> 1. 例如WWDG（窗口定时器中断），我们也称窗口看门狗，这个是用来监测程序运行状态的中断，例如程序卡死了，没有及时喂狗，窗口看门狗就会申请中断，这时我们的程序就会跳转到窗口看门狗的中断程序里，我们此时就可以在中断程序里进行一些错误检查
> 2. PVD（电源电压检测），如果供电电压不足，PVD电路就会申请中断，在中断里就可以知道现在是供电不足，电池快要没电了，可以执行保存数据的程序。
>
> 这些中断资源的右侧都附写有地址：这是因为我们程序中的中断函数的地址是由编译器来分配的，是不固定的，但是我们的中断跳转**由于硬件的限制**，只能跳到固定的地址执行程序，所以为了让硬件跳转到一个地址不固定的中断函数里，就需要在内存中定义一个存放（中断函数）地址的列表（我们称为向量表），这个列表用来存放不固定的中断函数的地址，但是列表本身的地址是固定的（也就是上图中表格右侧所示的地址）。中断发生时程序就会跳转到这个表里（上图中表格右侧所示的地址），然后在表里读取到对应的中断函数的地址后由编译器自动加上一条跳转到中断函数的代码，这样中断跳转就可以跳转到存放在任意位置的中断函数了并执行了。
>
> 示意图如下：
>
> ![image-20230130174104079](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130174104079.png)
>
> - 图中蓝色框部分表示中断向量表，存放中断函数的地址
> - 绿色部分表示中断跳转流程
>
> 存放中断函数地址的列表称为**中断向量表**。相当于中断跳转的一个跳板，我们用C语言编程是不需要管这个表的，编译器都帮我们做好了跳转的工作。

**我们要学习的就是EXTI中断**：	

> ![image-20230130171635073](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130171635073.png)

## NVIC基本结构

NVIC：嵌套中断向量控制器，在STM32中用来统一分配和管理中断，是一个内核外设，CPU的“小助手”

> ![image-20230130201330237](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130201330237.png)
>
> n表示一个外设（如EXTI，TIM...）可能会占用多个中断通道，所以这里有n条线。
>
> NVIC只有一个输出口，其根据每个中断的优先级分配中断的先后顺序，之后通过这个输出口告诉CPU该处理哪个中断。用医院的例子来理解就是CPU是医生，NVIC就是医院的叫号系统。

### NVIC优先级分组

> ![image-20230130202300391](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130202300391.png)

- 决定能否中断嵌套的优先级称为抢占优先级，抢占优先级高的可以进行中断嵌套。

- 优先级的值越小，优先级越高，0是最高优先级。

- 抢占优先级和响应优先级均相同的按中断号排队。中断号如下图：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130204349516.png" alt="image-20230130204349516" style="zoom:50%;" />

    中断号小的优先响应。

- 由于优先级寄存器总共有4位，于是分配给抢占优先级和响应优先级的寄存器个数组合可以是(4,0)、(3,1)、(2,2)、(1,3)、(0,4)，这个分组的方式在程序中是由我们来配置的。

    选好分组方式之后，我们在配置优先级的时候就要注意抢占优先级和响应优先级的取值范围了，不要超出上上个表中所示的取值。

- STM32不存在先来后到的排队方式，在任何时候都是优先级高的先响应。

关于抢占优先级和响应优先级以及NVIC基本结构的讲解见视频 [12：00~17:00](https://www.bilibili.com/video/BV1th411z7sn/?p=11&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

## EXTI

> ![image-20230130205106126](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130205106126.png)

- 软件触发：引脚啥事都不用干，程序里执行一句代码就可以触发中断。

- 相同的Pin不能同时触发中断：这个意思就是例如PA0和PB0不能同时用，或者PA1、PB1、PC1这样的GPIO_Pin一样的，只能选1个作为中断引脚。

    所以如果我们有多个IO口要作为中断引脚，要选择不同Pin的引脚，例如PA6和PA7、PA9和PB15、PB0和PB1。

- 通道数有16个GPIO_Pin，这对应的是GPIO_Pin_0到GPIO_Pin_15

    外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒，加上16个GPIO_Pin总共约20个中断通道/中断线路

    其中16个GPIO_Pin是外部中断的主要功能，而后面外加的这几个实际上是来“蹭网”的，为啥要来蹭网呢？因为这个外部中断有一个功能，就是从低功耗的停止模式下唤醒STM32

    - 对于PVD电源电压监测，当电源从电压过低恢复时，就需要PVD借助一下外部中断退出停止模式
    - 对于RTC闹钟来说，有时候为了省电，RTC定一个闹钟之后，STM32会进入停止模式，等到闹钟响的时候再唤醒，这也需要借助外部中断
    - 另外USB唤醒、以太网唤醒也都是类似的作用。

    当然我们学习的重点落在16个GPIO_Pin的外部中断，外加的4个中断我们了解一下即可。

- 触发响应方式：中断响应/事件响应。

    - 中断响应：申请中断，让CPU执行中断函数。
    - 事件响应：当外部中断检测到引脚电平变化时，选择触发一个事件，此时外部的中断信号不会通向CPU，而是通向其他外设，用来触发其他外设的操作，例如触发ADC转换，触发DMA等等。

    总结就是：中断响应是正常的流程——引脚电平触中断；事件响应不会触发中断，而是触发别的外设操作，属于外设之间的联合工作。

### EXTI基本结构***

> ![image-20230130213204298](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130213204298.png)

- GPIOA、B、C都是GPIO口的外设，每个外设有16个引脚，所以有16根线

- PA0、PB0、PC0这些通过AFIO中断引脚选择的电路模块（这是一个数据选择器，可以选择GPIO的引脚连接到后面与EXIT连接的通道上）选择之后，这三个只有其中一个能接到与EXTI相连接的通道0上，其他Pin也是同理。

- 通过AFIO选择后的16个通道，就接到了EXTI边沿检测及控制电路上，下面4个“蹭网”的外设也是并列接进来的。这些加起来就组成了EXTI的20个输入信号。

- 经过EXTI电路之后就分为了两种输出，**一种输出就接到了NVIC**来触发中断。另外本来20路EXTI输入应该对应20路输出，但是这里EXTI5~9、EXTI15_10的输出是合并5~9、10~15合成一路，此时外部中断5~9会触发同一个中断函数，10~15也只会触发同一个中断函数，所以我们在编程的时候，我们**在这两个中断函数里需要再根据标志位来区分到底是哪个中断进来的**。

    **另一种输出接到了其他外设**，用来触发其他外设操作，也就是上面所说的事件响应。

### EXTI框图

> ![image-20230130215331540](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215331540.png)

- 右下脚的“输入线”表示20根输入线，输入线先进入边沿检测电路，上面的上升沿触发选择寄存器、下降沿触发选择寄存器可以选择是上升沿触发、下降沿触发或者同时触发。

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215601585.png" alt="image-20230130215601585" style="zoom:50%;" />

- 接着触发信号就进入到了这个或门的输入端了（关于门电路的知识可以翻看后面关于门电路的讲解），如下图

    > ![image-20230130215659711](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215659711.png)

    此时软件触发（软件中断事件寄存器）和硬件触发（边缘检测电路的输出）都接到了这个或门上，也就是二者只要任意一个为1，或门输出就为1。

- 触发信号通过上面这个或门后就兵分两路，上面一路是用于**触发中断**的，下面一路是用于**触发事件**的，如下图

    > ![image-20230130221215023](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221215023.png)

    触发中断首先会置一个请求挂起寄存器，这相当于一个中断标志位，我们可以读取这个寄存器来判断是哪个通道触发的中断，如下图：

    > ![image-20230130221314702](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221314702.png)

    如果中断挂起寄存器置1，它就会继续往左走，和中断屏蔽寄存器进入一个与门，然后进入NVIC中断控制器，如下图

    > ![image-20230130221406617](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221406617.png)
    >
    > 这里的与门实际上相当于一个开关，因为对于与门来说：1与上任意数x，输出就是这个任意数x；0与上任意数x，输出始终为0，如下图所示：
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221551245.png" alt="image-20230130221551245" style="zoom:50%;" />
    >
    > 如果中断屏蔽寄存器给1，那么请求挂起寄存器的输出就可以直接通向NVIC中断控制器，也就是允许中断，如下图：
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221649228.png" alt="image-20230130221649228" style="zoom:50%;" />
    >
    > 如果中断屏蔽寄存器给0，那么请求挂起寄存器的输出无论是什么，给到NVIC中断控制器的输入都是0，相当于屏蔽了中断，如下图：
    >
    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221728877.png" alt="image-20230130221728877" style="zoom:50%;" />

    另一个触发事件的部分，如下图所示：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130221954289.png" alt="image-20230130221954289" style="zoom: 67%;" />
    >
    > 首先也是通过一个事件屏蔽寄存器进行开关控制，然后通过一个脉冲发生器到其他外设。
    >
    > 这里的脉冲发生器就是给一个电平脉冲，用来触发其他外设的动作。

- 另外框图上半部分的20表示的是20根线，代表20个通道，如下图所示：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130222158274.png" alt="image-20230130222158274" style="zoom: 67%;" />

- 如上图所示，框图最上面我们还可以看到外设接口和APB总线，我们可以通过总线访问这些寄存器。



## AFIO

> ![image-20230130214529982](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130214529982.png)

上图中右边的小图就是AFIO选择中断引脚的结构图。它可以选择GPIOx的某一个Pin接到EXTI上。如下图所示：

> ![image-20230130214745537](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130214745537.png)
>
> 梯形部分所示的就是一个数据选择器。

# 门电路

## |或门

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215749994.png" alt="image-20230130215749994" style="zoom:50%;" />

- 或门可以有多个输入，但只有一个输出
- 在输入端只要有一个是高电平1，则输出就是高电平
- 只有输入全部为0，输出才为0

## &与门

> ![image-20230130215954148](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130215954148.png)

- 与门可以有多个输入，但只有一个输出

- 在输入端只要有一个是低电平0，输出就是0

- 只有输入全部为1，输出才为1

## !非门

> ![image-20230130220152266](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130220152266.png)

- 非门只有一个输入一个输出
- 输入1输出0
- 输入0输出1

# 数据选择器

> 、![image-20230130220507919](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\5 中断\Note\image-20230130220507919.png)

- 数据选择器有多个输入，一个输出
- 侧面有选择控制端，根据控制端的数据，可以从输入选择一个输入接到输出