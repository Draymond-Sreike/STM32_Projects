# 定时器

> ![image-20230202152803036](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202152803036.png)

- 定时器最基本的功能：定时触发中断

- 例子：STM32中定时器的基准时钟一般是主频72MHz，如果我们对72MHz计72个数，那就是1MHz也即1us的时间；如果计72000个数，那就是1KHz也即1ms的时间

- 以下三个寄存器构成了定时器最核心的部分，我们把这一块电路称为时基单元

    - 计数器：用来执行计数定时的一个寄存器，每来一个时钟计数器就可以加1
    - 预分频器：可以对计数器的时钟进行**分频**，让计数更加灵活
    - 自动重装寄存器：用于设定计数器的计数目标值，就是要计数多少次后申请中断的一个设定

    这些16位的寄存器，2^16=65536，此时如果设置预分频器最大，自动重装最大，则定时器的最大定时时间就是59.65s，接近一分钟。计算的方式是：72MHz/65536/65536，此时得到中断的频率，取倒数就是59.65s。

    理解这个预分频器和重装寄存器其实可以这样：主频时钟一次**点**一下预分频器，先点满预分频器，点满一次预分频器就点一次自动重装寄存器，这样直到把自动重装寄存器点满就申请中断。

    所以如果我们嫌59.65s的定时不够，还可以**配置STM32的定时器进行级联**，当第一个定时器59.65s点满一次申请中断时，就来到第二个定时器加点，这样直到把第二个定时器的预分频器点满，才来点第二个定时器的自动重装寄存器，这样一直直到把第二个定时器的自动重装寄存器点满，就大概需要8000年的时间了。计算方式是：59.65(s)*65536\*65536 ≈ 8000(年)

    **如果三个定时器级联，最大计时还可以达到34万亿年，可见小小的STM32的3个定时器级联就能实现丈量宇宙年龄的能力**。用STM32定时，就能实现从宇宙诞生一直计时直到宇宙灭亡，这个还是非常厉害的。

## 定时器类型

> ![image-20230202155341828](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202155341828.png)

## 基本定时器结构（以及定时中断原理介绍）

> ![image-20230202184315293](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202184315293.png)

- 预分频器、自动重装寄存器、计数器构成了最基本的计数计时电路，称它们所组成的电路为**时基单元**

- 预分频器的输入是基准计数时钟，由于**基本定时器只能选择内部时钟**，所以我们可以认为预分频器的输入直接就是内部时钟CK_INT，内部时钟的来源是RCC_TIMxCLK，其频率值一般是系统的主频72MHz，所以通向时基单元的计数基准频率就是72MHz

- 预分频器（PSC）可以对72MHz的计数时钟进行预分频。

    - 例如，如果预分频器写0，那就是不分频，或者说是1分频，这时输出频率=输入频率=72MHz

    - 如果预分频器写1，那就是2分频，输出频率=输入频率/2=36MHz
    - 写2就是3分频，输出=输入/3......以此类推。

    所以预分频器的实际分频=寄存器值+1。由于预分频器是16位的，可写入的值最大是65535，那么最大的分频就是65536。预分频器就是对输入的基准频率提前进行一个分频的操作，其实现和理解可以参考本节“定时器”文首内容中提到的“打点”。

- 计数器（CNT）可以对预分频后的计数时钟进行计数，计数时钟每来一个上升沿，计数器就加1，这个计数器是16位的，所以里面的值可以从0一直加到65535，之后再加1，计数器就会回到0重新开始，所以计数器的值会在计时的过程中不断地自增，当自增运行到（自动重装寄存器所设定的）目标值时就会产生中断，此时完成一次定时任务。
    - 自动重装寄存器可以存储计数器计数的目标值，它也是16位的。在定时器运行的过程中，计数器的计数值不断自增，自动重装寄存器的值固定为一个目标值，计数器自增的过程中不断与目标值进行比较，当计数值等于目标值时，也即计时时间到，完成一次计时任务，此时就会产生一个中断信号，并且清零计数器，计数器便开始下一次的计数计时

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202193119559.png" alt="image-20230202193119559" style="zoom:50%;" />
>
> - 上图中向上的折现箭头UI表示计数器计数达到目标值时产生中断信号，计数值等于目标值产生的中断我们称为**更新中断**，产生的更新会通往NVIC，我们再配置好NVIC的定时器通道，此时定时器的更新中断就能得到CPU的响应了
>
> - 向下的折现箭头U表示计数器计数达到目标值时产生一个事件，对应的事件我们称为**更新事件**，更新事件不会触发中断，但可以触发内部其他电路的工作。
> - 更新中断和更新事件会**同时产生**。

## 主模式触发DAC功能简介

该功能能让部分硬件在不受程序的控制下实现自动运行。如果能把这个主从触发模式掌握好，在某些情景下可以极大地减轻CPU的负担。

在我们使用DAC时，需要每隔一段时间启动DAC进行转换，正常思路来设计的话是设置一个定时器产生中断，每个一段时间定时器产生中断并执行中断函数，在中断函数中用代码启动一次DAC转换，这样是没有问题的，但是这样会使主程序处于频繁被中断的状态，这样会影响主程序的运行和其他中断的响应。

所以定时器就设计了一个主模式，使用这个主模式可以把这个定时器的更新事件U映射到触发输出TRGO（Trigger Out）的位置，然后TRGO直接接到DAC的触发转换引脚上，这样DAC就不需要再通过中断函数来进行软件触发了，仅需要把更新事件通过主模式映射到TRGO，然后TRGO就会直接触发DAC。整个过程不需要软件参与，实现了硬件的自动化，这就是主模式的作用。

该模式的执行示意图如下：

> ![image-20230202195000923](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202195000923.png)	

## 通用定时器基本结构

> ![image-20230202203943433](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202203943433.png)

与基本定时器一样的是，通用定时同样也有时基单元

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202204100563.png" alt="image-20230202204100563" style="zoom: 67%;" />

工作流程也与基本定时器基本一致。不过对于通用定时器而言，计数器的计数模式不止向上计数这一种，还有向下计数，中央对齐计数：

- 向上计数：计数器从0开始向上自增，计到重装值，清零同时申请中断，然后开始下一轮，依次循环。示意图如下：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202204712963.png" alt="image-20230202204712963" style="zoom:50%;" />

- 向下计数：从重装值开始，向下自减少，减到0后回到重装值同时申请中断，然后开始下一轮，依次循环。示意图如下：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202204829148.png" alt="image-20230202204829148" style="zoom:50%;" />

- 中央对齐计数：从0开始先向上自增直到重装值，然后申请中断，然后再向下自减，减到0再申请中断，然后继续下一轮，依次循环。示意图如下：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202204950436.png" alt="image-20230202204950436" style="zoom:50%;" />

基本定时器仅支持向上计数，通用定时器则三种方式都支持。但我们多用的还是向上计数模式。

**内外时钟源选择和主从触发模式的结构**：

> ![image-20230202210056928](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202210056928.png)

基本定时器只能选择内部时钟，也就是系统频率72MHz，到了通用定时器这里，时钟源不仅可以选择内部的72MHz时钟还可以选择外部时钟，这些外部时钟可以是：

- TIMX_ETR引脚上的外部时钟，ETR(External)引脚的位置可以参考引脚定义表：

    > ![image-20230202210751853](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202210751853.png)
    >
    > 这里TIM2_CH1_ETR表示TIM2的CH1和ETR都复用在了PA0引脚上。

    这里我们可以在这个TIM2的ETR引脚（即PA0）上接一个外部方波时钟，然后配置内部的极性选择、边沿检测和预分频器电路，再配置一下输入滤波电路，这些电路可以对外部时钟信号进行一定的整形滤波（因为外部时钟信号难免会有毛刺）。如下图所示：

    > ![image-20230202211240412](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202211240412.png)

    滤波后的信号就可以兵分两路，一路通过ETRF进入触发控制器，紧跟着就可以选择作为时基单元的时钟了。如果我们想通过ETR引脚提供时钟，或者想对ETR时钟进行计数从而把这个定时器当作一个计数器来用，那么就可以配置刚才所描述的这一路电路，其示意图如下：

    > ![image-20230202211509762](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202211509762.png)

    在STM32中这一路也叫“**外部时钟模式2**”。

- TRGI(Trigger In)等其他外部时钟对应**外部时钟模式1**，其相关原理详细介绍见视频 [19:00~25:00](https://www.bilibili.com/video/BV1th411z7sn/?p=13&spm_id_from=pageDriver&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

总结：

- 外部时钟模式1的输入可以是，ETR引脚、其他定时器(ITR0、ITR1、ITR2、ITR3)、CH1引脚的边沿、CH1引脚和CH2引脚。如下图：

    > ![image-20230202212810848](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202212810848.png)

​		可以看到“外部时钟模式1”还是比较复杂的，这不仅仅是为扩大时钟输入的范围，更多是为了某些特殊的应用场景而设计的（例如为了实现定时器的级联而设计了ITR0、ITR1、ITR2、ITR3）

​		**一般情况下外部时钟通过ETR引脚并选择“外部时钟模式2”即可。**这一路最简单最直接。

## 高级定时器基本结构

> ![image-20230202214138651](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202214138651.png)

- 高级定时器比通用定时器多了一个**重复次数计数器**，这个计数器可以实现指定若干个计数器计数任务完成后才触发更新事件和中断（以前都是计数器一次计数任务完成就触发更新事件和中断）。这相当于对输出的更新信号又做了一次分频，对于基本定时器的计时时间是59s左右，到了高级计数器这里最大就可以再乘一个65536，这样又提升了最大的计时时间长度。
- 另外关于DTG（死区生成电路）、输出互补PWM波驱动三相无刷电机、刹车输入功能的简介见视频[28:00~30:00](https://www.bilibili.com/video/BV1th411z7sn/?p=13&spm_id_from=pageDriver&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

# 定时中断基本结构***

> ![image-20230202215132278](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202215132278.png)

- 运行控制：控制定时器启动停止、计数方式，即控制时基单元运行。

- 左边为时基单元提供时钟的部分：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202215824612.png" alt="image-20230202215824612" style="zoom:50%;" />

    - 可以选择RCC内部提供时钟（定时器定时中断可以用这一路）

    - 可以选择ETR引脚提供的外部时钟模式2（定时器外部时钟中断可以用这一路）

    - 可以选则TRGI（触发输入）提供外部时钟，即外部时钟模式1，对应的有：

        - ETR外部时钟
        - ITRx其他定时器
        - Tlx输入捕获通道

        以上即基本定时器所常用的时钟源了。

    - 编码器模式一般是编码器独用的模式，普通的时钟用不到。

- 右边的中断信号输入：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202220324669.png" alt="image-20230202220324669" style="zoom:50%;" />

    首先中断信号会在状态寄存器置一个中断标志位，这个标志位通过**中断输出控制**，到NVIC申请中断。

    中断输出控制是因为定时器模块有很多地方要申请中断，例如更新会申请中断、触发信号也会申请中断、输入捕获和输出比较匹配时也会申请中断：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202220521309.png" alt="image-20230202220521309" style="zoom:50%;" />

    所以这些定时器内部产生的中断都需要通过中断输出控制。如果需要这个中断就允许，不需要就禁止，简单来说这个中断输出控制就是一个中断输出的允许位，如果需要某个中断就配置允许。

# 时序

关于各个寄存器的时序讲解见视频 [32:00~39:00](https://www.bilibili.com/video/BV1th411z7sn/?p=13&spm_id_from=pageDriver&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

## 预分频器时序

> ![image-20230202222542991](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202222542991.png)



**计数器计数频率（CK_CNT）=基准时钟频率(CK_PSC）/预分频（预分频器值PSC+1）**。

## 计数器时序

> ![image-20230202223041735](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202223041735.png)

- 定时器的中断标志位需要手动清0

**计数器溢出频率(即中断申请频率CK_CNT_OV)=CK_CNT(计数器计数频率)/（ARR自动重装寄存器值+1）**

联立计数器计数频率公式，可得：

**计数器溢出频率(CK_CNT_OV)=基准时钟频率(CK_PSC）/预分频（预分频器值PSC+1）/（ARR自动重装寄存器值+1）**

如果我们想算溢出时间，即中断申请的时间周期，则对溢出频率取倒数即可。

## 影子寄存器（有无预装时序）

该寄存器的存在是设置预分频器分频更改、计数器目标值更改是否立即生效所用。

该部分内容讲解见视频 [38:00~41:00](https://www.bilibili.com/video/BV1th411z7sn/?p=13&spm_id_from=pageDriver&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

# RCC时钟树

> ![image-20230202225502128](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202225502128.png)

- RCC时钟树是STM32用来产生和配置时钟并且把配置好的时钟发送到各个外设系统的

- 时钟是所有外设运行的基础，所以时钟也是最先需要配置的

- 程序中主函数执行前会执行一个SystemInit函数，这个函数就是用来配置时钟树的

- 无论是高级、通用、基本定时器，它们的内部基准时钟都是72MHz（前提是我们没有乱更改SystemInit函数里的配置）

- 我们程序中写RCC_APBxPeriphCmd函数控制的地方是这里：

    > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\6 定时器\Note\image-20230202230638478.png" alt="image-20230202230638478" style="zoom:50%;" />
    >
    > 即红框所框的与门，ENABLE打开时钟就是使得来自系统的时钟能够通过与门输出给外设

此部分内容包含时钟产生电路的四个震荡源/晶振（可以给RTC、看门狗、AHB、APB2、APB1提供时钟，外部有石英振荡器，内部有RC振荡器）、SystemInit函数配置时钟的逻辑（包括锁相环倍频）、CSS(Clock Security System时钟安全系统，负责震荡源切换)、时钟分配电路（AHB、APB1、APB2总线预分频逻辑）

该部分内容讲解见视频 [41:00~47:00](https://www.bilibili.com/video/BV1th411z7sn/?p=13&spm_id_from=pageDriver&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)