# GPIO简介

> ![image-20230118143808406](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118143808406.png)
>
> - 对于第3点，数据0就是低电平0V，数据1就是高电平3.3V。
>
>     部分引脚可容忍5V的意思可以在这个端口输入5V的电压，并且也认为是高电平，但是对于输出而言最大只能输出3.3V，因为供电也就只有3.3V。至于哪些端口能够容忍5V，我们可以查看[STM32的引脚定义图](D:\大学\单片机学习\STM32F103C8T6引脚定义.png)。
>
>     ![image-20230118144351505](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118144351505.png)
>
>     图中带FT的就表示可以容忍5V；不带FT的就只能输入3.3V。
>
> - 对于第5点“外接模块电平信号输入”，如果这个外接模块的对外输出是模拟量，那么GPIO可以配置成模拟输入的模式，再配合内部的ADC外设就可以直接读取端口的模拟电压了。

# GPIO基本结构

> ![image-20230118144942219](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118144942219.png)

- GPIO外设的名称按照GPIOA~GPIOx来命名，每个GPIOx外设都有16个引脚（Px0~Px15）

- 每个GPIO模块内，主要包含了寄存器和驱动器：
    - 寄存器是一段特殊的存储器，内核可以通过APB2总线对寄存器进行读写，这样就可以完成输出电平和读取电平的功能了。
    - 寄存器的每一位对应一个引脚。对应的寄存器写1，引脚就会输出高电平，写0就输出低电平；读取时也遵循这样的规则。
    - 由于STM32是32位的单片机，所有STM32内部的寄存器都是32位的，但是端口只有16位，所以这些GPIO的寄存器只有低16位有对应端口，高16位是没有用到的。
    - 寄存器负责存储数据，驱动器则是用来增加信号的驱动能力的。如果要进行点灯操作，是需要驱动器来增强驱动能力的。

# GPIO位结构

> ![image-20230118150219521](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150219521.png)
>
> ![image-20230118150320642](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150320642.png)

### 输入部分

#### 保护二极管

在输出引脚/端口这里的两个二极管是用来对电压进行限幅的

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150459405.png" alt="image-20230118150459405" style="zoom:50%;" />
>
> 上面的VDD接3.3V，下面的VSS接0V。

如果输入电压比3.3V还要高，那么上面的二极管就会导通，由此输入电压产生的电流就会流入VDD而不会流入内部电路，如下图所示

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150706760.png" alt="image-20230118150706760" style="zoom:50%;" />

这样就可以避免电压过高对电路内部造成损害。

同理如果输入电压低于0V，下面的二极管就会导通，电流就会从VSS流出I/O引脚，而不会从电路内部汲取电流，这样同样起到了保护内部电路的效果，如下图

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150931137.png" alt="image-20230118150931137" style="zoom:50%;" />

如果输入电压在0~3.3V之间，那么两个二极管就均不会导通，这时的二极管对电路没有影响，这就是保护二极管的用途。

#### 上拉/下拉电阻

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118151853381.png" alt="image-20230118151853381" style="zoom:50%;" />

这里的两个电阻分别是上拉（靠近VDD）和下拉（靠近VSS）电阻。

电阻旁边的开关可以通过程序配置其通断。

- 如果两个都断开就是浮空输入模式

- 如果上面导通，下面断开，就是上拉输入模式。

- 如果下面导通，上面断开，就是下拉输入模式

    - 上拉/下拉输入模式可以给输入提供一个默认的输入电平。因为一个数字的端口，输入不是高电平即是低电平，如果输入引脚啥都不接，到底算是高还是低电平呢，这就不好说了。

        实际情况是如果啥都不接，输入就会处于一种浮空的状态，引脚的输入电平极易受外界干扰而改变。

        为了避免引脚悬空导致的输入数据不确定，我们就需要在这里加上上拉或者下拉电阻。

    - 如果接上拉电阻，当引脚悬空时还有上拉电阻来保证引脚处于高电平。所以**上拉输入又可以称为默认高电平的输入模式**。下拉同理。

    - 上拉/下拉的电阻的阻值较大，是一种弱上拉和弱下拉，目的是尽量不影响正常的输入操作。

#### 施密特触发器

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118152847578.png" alt="image-20230118152847578" style="zoom:50%;" />
>
> 这里中文文档写肖特基触发器是错的，是施密特触发器。

这里的施密特触发器的作用是对输入电压进行整形。其执行逻辑是：如果输入电压大于某一阈值，输出就会瞬间升为高电平；如果输入电压小于某一阈值，输出就会瞬间降为低电平。

##### 应用举例

> ![image-20230118153210986](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118153210986.png)
>
> 当输入高于上限时，输出马上升为高电平，之后当输入低于上限，但仍高于下限时，输出仍然维持高电平，直至输入低于下限，输出才变为低电平，并且之后如果输入高于下限但仍低于上限，输出维持低电平。
>
> 可以看到相较于输入信号（红色），经过整形的信号（蓝色）就很完美了。
>
> 图中绿线表示两个比较阈值，并且中间留有一定的变化范围，这样可以有效地避免因信号波动造成的输出抖动现象。

经过施密特触发器整形后的波形就可以直接写入输入数据寄存器了

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118153857740.png" alt="image-20230118153857740" style="zoom:50%;" />

然后我们再用程序读取输入数据寄存器某一位的数据即可知道端口的输入电平。

施密特上方还有两条线路

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118154112142.png" alt="image-20230118154112142" style="zoom: 50%;" />

这是连接到片上外设的一些端口，

- 其中模拟输入是连接到ADC上的，因为ADC需要接受模拟量，所以"模拟输入"的线接到了触发器的输入端；
- 而复用功能输入是连接到其他需要读取端口的外设上的，例如串口的输入引脚，这根线接收的是数字量，所以在触发器的输出端

### 输出部分

#### 寄存器

输出部分可以由输出数据寄存器或片上外设（复用输出功能）控制：

> ![image-20230118165240866](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118165240866.png)

两种控制方式通过数据选择器接到了输出控制部分：

- 如果选择通过输出数据寄存器进行控制，就是普通的IO口输出。写这个输出数据寄存器的某一位就可以操作对应的某个端口了。
    - 注意输出数据寄存器左边还有一个位设置/清除寄存器，这个可以用来单独操作输出数据寄存器的某一位，而不影响其他位。因为输出数据寄存器同时控制16个端口，并且该寄存器只能整体读写，所以如果想单独控制其中的某一个端口而不影响其他端口，就需要一些的操作方式：
        - 第一种方式是先读出该寄存器，然后用按位与/或的方式(&=、|=)更改某一位，最后再将更改后的数据写回去。这种方法较为麻烦且效率不高，不适合于IO口的操作。
        - 第二种方式是通过配置位设置/清除寄存器，如果我们要对某一位进行置1操作，在位设置寄存器的对应位写1即可，剩下不需要操作的位写0，这样位设置寄存器通过其特殊的电路就能将输出数据寄存器中对应的位置置为1，而位设置寄存器写0的位对应的输出数据寄存器的位就保持不变。而如果想对某一位进行清0的操作，就在位清楚寄存器的对应位写1即可，这样也会通过特殊的电路将对应的输出数据寄存器的位清0。这样就保证了操作输出数据寄存器的某一位而不影响其他位。
        - 第三种方式是读写STM32中的"位带"区域。此方式暂不予以展示。
        - 我们主要是通过库函数来操作，而库函数使用的是第二种方式：配置位设置/清除寄存器。

#### MOS管

输出控制之后就接到了两个MOS管，如下

> ![image-20230118171551801](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118171551801.png)

- MOS管是一种电子开关，负责将IO口接到VDD或VSS
    - 可以通过信号来控制这种开关的导通和关闭

- 可以选择三种输出方式：推挽、开漏、关闭

    - 推挽输出模式下，P-MOS和N-MOS均有效。

        - 输出数据寄存器为1时，上管（P-MOS）导通，下管（N-MOS）断开，输出直接接到VDD，输出的是高电平
        - 输出数据寄存器为0时，上管（P-MOS）断开，下管（N-MOS）导通，输出直接接到VSS，输出的是低电平

        这种推挽输出模式的高低电平都具有较强的驱动能力，所以推挽输出模式也可以叫强推输出模式。在推挽输出模式下，STM32对IO口具有绝对的控制权，高低电平均为STM32说了算。

    - 开漏输出模式下，P-MOS是无效的，只有N-MOS在工作

        > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118172255296.png" alt="image-20230118172255296" style="zoom:50%;" />

        - 输出数据寄存器为1时，下管断开，这时输出相当于断开，输出电路部分处于高阻状态，也可以认为输出电路相当于什么都不接，处于浮空状态。
        - 输出数据寄存器为0时，下管导通，这时输出直接接到VSS，输出低电平。

        1. 注意：这种模式下只有低电平有驱动能力，高电平是没有驱动能力的。

        2. 应用1：（通信）这种模式可以作为通信协议的驱动方式，例如I2C通信的引脚就是使用开漏输出模式，另外在多机通信的情况下，这个模式可以避免各个设备之间的相互干扰。

        3. 应用2：（输出5V电平信号）这种开漏输出模式还可以用于输出5V的电平信号。我们在IO口外接一个上拉电阻到5V的电源。

            > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118172853244.png" alt="image-20230118172853244" style="zoom:50%;" />

            - 当输出低电平时，由内部的N-MOS直接接VSS
            - 当输出高电平时，由外部的上拉电阻拉高至5V。

            这样就可以输出5V的电平信号，用于兼容一些5V电平的设备了。

    - 输出关闭模式是当引脚配置为输入模式时所用的模式，此模式下两个MOS管均失效

        > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118173439528.png" alt="image-20230118173439528" style="zoom:50%;" />

        此时端口的信号由外部进行控制，此时IO口就可以用于输入信号了

        > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118173529766.png" alt="image-20230118173529766" style="zoom:50%;" />

以上即GPIO位结构的全部介绍。

# GPIO模式

> ![image-20230118173636918](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118173636918.png)

通过操作端口配置寄存器，GPIO位结构的电路就会根据我们的配置进行改变（比如开/关的通断，MOS管是否有效、数据选择器的选择等）。

## 输入模式

### 浮空/上拉/下拉输入

> ![image-20230118174039592](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118174039592.png)

这三种输入模式都是数字的输入口，电路结构是基本一样的，共同的特征是都可以读取端口的高低电平，区别就在于上拉电阻和下拉电阻的连接（这些电阻对应开关的通断）。

当引脚悬空时：

- 上拉输入默认是高电平
- 下拉输入默认是低电平
- 浮空输入的电平是不确定的。所以在使用浮空输入时，端口一定要街上一个连续的驱动源，不能出现浮空（或者也可以叫"悬空"）的状态

输入模式的电路结构如下

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118174721577.png" alt="image-20230118174721577" style="zoom:50%;" />

- 可以看到在输入模式下，输出驱动器断开，端口只能输入而不能输出
- 输入驱动器中的两个电阻附件的开关的通断组合就可以配置为上拉/下拉/悬空模式，具体可以看“GPIO位结构-输入部分-上拉/下拉电阻”的讲解
- 然后输入通过施密特触发器进行波形整形后，连接到输入数据寄存器
- 另外右边的输入保护部分中，上方的保护二极管写的是VDD或VDD_FT，这就是3.3V端口和容忍5V端口的区别。这个容忍5V的引脚，上边的保护二极管要做一下处理，不然这里直接接VDD(3.3V)的话，外部再接5V就会导致上边的二极管开启，并且产生较大的电流，这是不太妥当的。

### 模拟输入

> ![image-20230121214909697](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121214909697.png)

模拟输入是ADC数模转换器的专属配置，此模式下输出信号通路的开关处于断开状态，而施密特触发器也处于关闭状态，GPIO位结构状态如下图所示

> ![image-20230121220926229](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121220926229.png)

此时的引脚直接连接到片上外设

> ![image-20230121233310475](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121233310475.png)

**所以当我们使用ADC时，将引脚配置为模拟输入即可**，其他时候一般用不上模拟输入。

## 输出模式

### 开漏输出与推挽输出

> ![image-20230121233431711](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121233431711.png)

数字输出口，用于输出高低电平，二者的区别在于

- **开漏输出的高电平呈现高阻态，没有驱动能力**（P-MOS无效则为开漏输出模式，此时P-MOS所在的通路可以视为断路），只有强下拉，没有强上拉作用

- **推挽输出的高低电平都具有驱动能力**（P-MOS有效则为推挽输出模式），有强上拉和强下拉作用

    两种模式的N-MOS都有效

    （以上内容所描述的MOS请参见"GPIO位结构-输出部分-MOS管"）

**另外在输出模式下，输入模式也有效的；但输入模式下，输出模式是无效的**。这是因为**一个端口只能有一个输出，但可以有多个输入**。所以当配置成输出模式时，内部也可以顺便输入一下，这是允许的。

### 复用开漏输出和推挽输出

> ![image-20230121234251323](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121234251323.png)

这两个与普通的开漏和推挽输出差不多，只不过复用模式下，引脚电平是由片上外设控制

> ![image-20230121234433697](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121234433697.png)
>
> 可以看到这种模式下输出数据寄存器的通路断开，引脚的控制权转移到了片上外设

在输出部分，片上外设也可以读取引脚电平，同时普通的输入数据寄存器读取也是有效的，如下

> ![image-20230121234555912](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121234555912.png)

**实际上在GPIO的8种模式中，除了模拟输入这个模式会关闭数字的输入功能，其它的7个模式中，所以的输入都是有效的**。如下图所示

> ![image-20230121234912831](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121234912831.png)

# 手册使用

## 外设的GPIO配置

> ![image-20230121235019935](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121235019935.png)

当我们使用这些**片上外设的引脚**时，可以参考这个表里给的配置

## GPIO寄存器

### 端口配置寄存器

> ![image-20230121235214416](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121235214416.png)

 每个端口由4个寄存器进行配置，16个端口就需要64个寄存器。因为STM32有16个端口，STM32又是32位，所以STM32中有两个配置寄存器，一个是高寄存器，一个是低寄存器，如下

> ![image-20230121235451307](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121235451307.png)
>
> ![image-20230121235741969](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121235741969.png)

具体如何配置可以参考手册中中的说明：

> ![image-20230121235835251](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121235835251.png)

 另外GPIO配置还多了一项GPIO速度配置，如下：

> ![image-20230121235941733](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230121235941733.png)

位结构图中并没有速度这个参数的电路结构。

这个GPIO的输出速度可以限制输出引脚的最大翻转速度，这个设计出来是为了低功耗和稳定性的，一般要求不高的时候配置为50MHz即可

### 端口输入数据寄存器

> ![image-20230122000913140](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122000913140.png)

这个寄存器使用的是低16位的引脚，高16位的引脚没有用。该寄存器对应GPIO位结构中的位置如下：

> ![image-20230122001129524](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122001129524.png)

### 端口输出数据寄存器

> ![image-20230122001156483](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122001156483.png)

对应GPIO位结构中的位置如下

> ![image-20230122001217068](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122001217068.png)

同样低16位对应16个引脚，高16位没有用。

### 端口位设置/清除寄存器

> ![image-20230122003101390](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122003101390.png)

该寄存器的高16位是进行位清除的，低16位是进行位设置的。

写1即位设置或清楚，写0即不产生影响。

### 端口位清除寄存器

这个寄存器的低16位功能与端口位设置/清除寄存器的高16的功能是一样的，均是位清除功能。

> ![image-20230122003317799](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122003317799.png)

这个寄存器存在是为了方便操作而设置的：我们如果想单一地进行位设置或位清除，位设置时就用端口位设置/清除寄存器的低16位，位清除时就用端口位清除寄存器的低16位，这样在设置和清除时都是使用低16位的数据，这样就方便一些。



如果我们是想对多个端口同时进行位设置和位清除，那就使用端口位设置/清除寄存器即可，这样可以保证位设置和位清除的同步性。（如果我们对信号的同步性要求不高的话，先位设置再位清除也是没有问题的）

### 端口配置锁定寄存器

> ![image-20230122004614034](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122004614034.png)

这个寄存器可以对端口的配置进行锁定，防止意外更改。这个我们用的暂时不多，使用方法见手册。

# 拓展

## 三极管电路知识

因为三极管的通断是需要在发射极和基极之间产生一定的开启电压的，如果我们把负载接在发射极一边，则可能导致三极管无法开启，如下图所示：

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230122005242278.png" alt="image-20230122005242278" style="zoom:50%;" />





















1











> 
>
> 
>
> ![image-20230118145003763](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118145003763.png)
>
> > > 在STM32中所有的GPIO都是挂载在APB2外设总线上的。
> >
> > 
> >
> > 
