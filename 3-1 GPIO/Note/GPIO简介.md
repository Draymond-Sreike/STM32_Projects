# GPIO简介

> ![image-20230118143808406](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118143808406.png)
>
> - 对于第3点，数据0就是低电平0V，数据1就是高电平3.3V。
>
>     部分引脚可容忍5V的意思可以在这个端口输入5V的电压，并且也认为是高电平，但是对于输出而言最大只能输出3.3V，因为供电也就只有3.3V。至于哪些端口能够容忍5V，我们可以查看[STM32的引脚定义图](D:\大学\单片机学习\STM32F103C8T6引脚定义.png)。
>
>     ![image-20230118144351505](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118144351505.png)
>
>     图中带FT的就表示可以容忍5V；不带FT的就只能输入3.3V。
>
> - 对于第5点“外接模块电平信号输入”，如果这个外接模块的对外输出是模拟量，那么GPIO可以配置成模拟输入的模式，再配合内部的ADC外设就可以直接读取端口的模拟电压了。

# GPIO基本结构

> ![image-20230118144942219](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118144942219.png)

- GPIO外设的名称按照GPIOA~GPIOx来命名，每个GPIOx外设都有16个引脚（Px0~Px15）

- 每个GPIO模块内，主要包含了寄存器和驱动器：
    - 寄存器是一段特殊的存储器，内核可以通过APB2总线对寄存器进行读写，这样就可以完成输出电平和读取电平的功能了。
    - 寄存器的每一位对应一个引脚。对应的寄存器写1，引脚就会输出高电平，写0就输出低电平；读取时也遵循这样的规则。
    - 由于STM32是32位的单片机，所有STM32内部的寄存器都是32位的，但是端口只有16位，所以这些GPIO的寄存器只有低16位有对应端口，高16位是没有用到的。
    - 寄存器负责存储数据，驱动器则是用来增加信号的驱动能力的。如果要进行点灯操作，是需要驱动器来增强驱动能力的。

# GPIO位结构

> ![image-20230118150219521](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150219521.png)
>
> ![image-20230118150320642](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150320642.png)

### 输入部分

#### 保护二极管

在输出引脚/端口这里的两个二极管是用来对电压进行限幅的

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150459405.png" alt="image-20230118150459405" style="zoom:50%;" />
>
> 上面的VDD接3.3V，下面的VSS接0V。

如果输入电压比3.3V还要高，那么上面的二极管就会导通，由此输入电压产生的电流就会流入VDD而不会流入内部电路，如下图所示

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150706760.png" alt="image-20230118150706760" style="zoom:50%;" />

这样就可以避免电压过高对电路内部造成损害。

同理如果输入电压低于0V，下面的二极管就会导通，电流就会从VSS流出I/O引脚，而不会从电路内部汲取电流，这样同样起到了保护内部电路的效果，如下图

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118150931137.png" alt="image-20230118150931137" style="zoom:50%;" />

如果输入电压在0~3.3V之间，那么两个二极管就均不会导通，这时的二极管对电路没有影响，这就是保护二极管的用途。

#### 上拉/下拉电阻

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118151853381.png" alt="image-20230118151853381" style="zoom:50%;" />

这里的两个电阻分别是上拉（靠近VDD）和下拉（靠近VSS）电阻。

电阻旁边的开关可以通过程序配置其通断。

- 如果两个都断开就是浮空输入模式

- 如果上面导通，下面断开，就是上拉输入模式。

- 如果下面导通，上面断开，就是下拉输入模式

    - 上拉/下拉输入模式可以给输入提供一个默认的输入电平。因为一个数字的端口，输入不是高电平即是低电平，如果输入引脚啥都不接，到底算是高还是低电平呢，这就不好说了。

        实际情况是如果啥都不接，输入就会处于一种浮空的状态，引脚的输入电平极易受外界干扰而改变。

        为了避免引脚悬空导致的输入数据不确定，我们就需要在这里加上上拉或者下拉电阻。

    - 如果接上拉电阻，当引脚悬空时还有上拉电阻来保证引脚处于高电平。所以**上拉输入又可以称为默认高电平的输入模式**。下拉同理。

    - 上拉/下拉的电阻的阻值较大，是一种弱上拉和弱下拉，目的是尽量不影响正常的输入操作。

#### 施密特触发器

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118152847578.png" alt="image-20230118152847578" style="zoom:50%;" />
>
> 这里中文文档写肖特基触发器是错的，是施密特触发器。

这里的施密特触发器的作用是对输入电压进行整形。其执行逻辑是：如果输入电压大于某一阈值，输出就会瞬间升为高电平；如果输入电压小于某一阈值，输出就会瞬间降为低电平。

##### 应用举例

> ![image-20230118153210986](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118153210986.png)
>
> 当输入高于上限时，输出马上升为高电平，之后当输入低于上限，但仍高于下限时，输出仍然维持高电平，直至输入低于下限，输出才变为低电平，并且之后如果输入高于下限但仍低于上限，输出维持低电平。
>
> 可以看到相较于输入信号（红色），经过整形的信号（蓝色）就很完美了。
>
> 图中绿线表示两个比较阈值，并且中间留有一定的变化范围，这样可以有效地避免因信号波动造成的输出抖动现象。

经过施密特触发器整形后的波形就可以直接写入输入数据寄存器了

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118153857740.png" alt="image-20230118153857740" style="zoom:50%;" />

然后我们再用程序读取输入数据寄存器某一位的数据即可知道端口的输入电平。

施密特上方还有两条线路

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118154112142.png" alt="image-20230118154112142" style="zoom: 50%;" />

这是连接到片上外设的一些端口，

- 其中模拟输入是连接到ADC上的，因为ADC需要接受模拟量，所以"模拟输入"的线接到了触发器的输入端；
- 而复用功能输入是连接到其他需要读取端口的外设上的，例如串口的输入引脚，这根线接收的是数字量，所以在触发器的输出端

### 输出部分

#### 寄存器

输出部分可以由输出数据寄存器或片上外设（复用输出功能）控制：

> ![image-20230118165240866](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118165240866.png)

两种控制方式通过数据选择器接到了输出控制部分：

- 器如果选择通过输出数据寄存器进行控制，就是普通的IO口输出。写这个输出数据寄存器的某一位就可以操作对应的某个端口了。
    - 注意输出数据寄存器左边还有一个位设置/清除寄存器，这个可以用来单独操作输出数据寄存器的某一位，而不影响其他位。因为输出数据寄存器同时控制16个端口，并且该寄存器只能整体读写，所以如果想单独控制其中的某一个端口而不影响其他端口，就需要一些的操作方式：
        - 第一种方式是先读出该寄存器，然后用按位与/或的方式(&=、|=)更改某一位，最后再将更改后的数据写回去。这种方法较为麻烦且效率不高，不适合于IO口的操作。
        - 第二种方式是通过配置位设置/清除寄存器，如果我们要对某一位进行置1操作，在位设置寄存器的对应位写1即可，剩下不需要操作的位写0，这样位设置寄存器通过其特殊的电路就能将输出数据寄存器中对应的位置置为1，而位设置寄存器写0的位对应的输出数据寄存器的位就保持不变。而如果想对某一位进行清0的操作，就在位清楚寄存器的对应位写1即可，这样也会通过特殊的电路将对应的输出数据寄存器的位清0。这样就保证了操作输出数据寄存器的某一位而不影响其他位。
        - 第三种方式是读写STM32中的"位带"区域。此方式暂不予以展示。
        - 我们主要是通过库函数来操作，而库函数使用的是第二种方式：配置位设置/清除寄存器。

#### MOS管

输出控制之后就接到了两个MOS管，如下

> ![image-20230118171551801](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118171551801.png)

- MOS管是一种电子开关，负责将IO口接到VDD或VSS
    - 可以通过信号来控制这种开关的导通和关闭

- 可以选择三种输出方式：推挽、开漏、关闭

    - 推挽输出模式下，P-MOS和N-MOS均有效。

        - 输出数据寄存器为1时，上管（P-MOS）导通，下管（N-MOS）断开，输出直接接到VDD，输出的是高电平
        - 输出数据寄存器为0时，上管（P-MOS）断开，下管（N-MOS）导通，输出直接接到VSS，输出的是低电平

        这种推挽输出模式的高低电平都具有较强的驱动能力，所以推挽输出模式也可以叫强推输出模式。在推挽输出模式下，STM32对IO口具有绝对的控制权，高低电平均为STM32说了算。

    - 开漏输出模式下，P-MOS是无效的，只有N-MOS在工作

        > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118172255296.png" alt="image-20230118172255296" style="zoom:50%;" />

        - 输出数据寄存器为1时，下管断开，这时输出相当于断开，输出电路部分处于高阻状态
        - 输出数据寄存器为0时，下管导通，这时输出直接接到VSS，输出低电平。

        1. 注意：这种模式下只有低电平有驱动能力，高电平是没有驱动能力的。

        2. 应用1：（通信）这种模式可以作为通信协议的驱动方式，例如I2C通信的引脚就是使用开漏输出模式，另外在多机通信的情况下，这个模式可以避免各个设备之间的相互干扰。

        3. 应用2：（输出5V电平信号）这种开漏输出模式还可以用于输出5V的电平信号。我们在IO口外接一个上拉电阻到5V的电源。

            > <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118172853244.png" alt="image-20230118172853244" style="zoom:50%;" />

            - 当输出低电平时，由内部的N-MOS直接接VSS
            - 当输出高电平时，由外部的上拉电阻拉高至5V。

            这样就可以输出5V的电平信号，用于兼容一些5V电平的设备了。

    - 输出关闭模式是当引脚配置为输入模式时所用的模式，此模式下两个MOS管均失效

        > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118173439528.png" alt="image-20230118173439528" style="zoom:50%;" />

        此时端口的信号由外部进行控制，此时IO口就可以用于输入信号了

        > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118173529766.png" alt="image-20230118173529766" style="zoom:50%;" />

以上即GPIO位结构的全部介绍。

# GPIO模式

> ![image-20230118173636918](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118173636918.png)

通过操作端口配置寄存器，GPIO位结构的电路就会根据我们的配置进行改变（比如开/关的通断，MOS管是否有效、数据选择器的选择等）。

## 输入模式

### 浮空/上拉/下拉输入

> ![image-20230118174039592](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118174039592.png)

这三种输入模式都是数字的输入口，电路结构是基本一样的，共同的特征是都可以读取端口的高低电平，区别就在于上拉电阻和下拉电阻的连接（这些电阻对应开关的通断）。

当引脚悬空时：

- 上拉输入默认是高电平
- 下拉输入默认是低电平
- 浮空输入的电平是不确定的。所以在使用浮空输入时，端口一定要街上一个连续的驱动源，不能出现浮空（或者也可以叫"悬空"）的状态

输入模式的电路结构如下

> <img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118174721577.png" alt="image-20230118174721577" style="zoom:50%;" />

- 可以看到在输入模式下，输出驱动器断开，端口只能输入而不能输出
- 输入驱动器中的两个电阻附件的开关的通断组合就可以配置为上拉/下拉/悬空模式，具体可以看“GPIO位结构-输入部分-上拉/下拉电阻”的讲解
- 然后输入通过施密特触发器进行波形整形后，连接到输入数据寄存器
- 另外右边的输入保护部分中，上方的保护二极管写的是VDD或VDD_FT，这就是3.3V端口和容忍5V端口的区别。这个容忍5V的引脚，上边的保护二极管要做一下处，不然这里直接接VDD(3.3V)的话，外部再接5V就会导致上边的二极管开启，并且产生较大的电流，这是不太妥当的。

### 模拟输入



> ![image-20230118145003763](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230118145003763.png)
>
> 在STM32中所有的GPIO都是挂载在APB2外设总线上的。



